# -*- coding: utf-8 -*-
"""
Created on Sun Feb 28 09:17:08 2021

Convert HEC-RAS 2D mesh and data to SRH-2D. The generated SRHGEOM and SRHMAT files can be loaded in SMS. 
However, current version of SMS (v13.1) can only handle mesh cell shapes of triangles and quadrilaterals.
In HEC-RAS 2D, there could be polyhedrons with more than four sides. It seems SMS will discard extra
 sides and read the mesh wrong. Future versions of SMS may handle polyhydrons correctly. 

Regardless, HEC-RAS 2D meshes can still be used with SRH-2D because the model itself can handle 
polyhedrons. We simply have to prepare all the input files outside of SMS. And that is the purpose
 of this code.

The developement of this code used/modified some of the functions in HaD-to-Py (Tomkovic 2016), e.g., 
the reading of HEC-RAS's 2D result files using the HDF module. 

References:

L. A. Tomkovic (2016), HaD-to-Py, https://github.com/latomkovic/HaD-to-Py (accessed Feb. 2021)

Author: Xiaofeng Liu, PhD, PE  
Penn State University
"""

import sys
import numpy as np
import h5py
import meshio
from scipy import interpolate
from osgeo import gdal

class RAS_2D_Data:
    """
    A class for HEC-RAS 2D data I/O, manipulation, and format conversion
    
    This class is designed to read HEC-RAS results in HDF format. It can 
    save RAS2D results into VTK format for visualization in Paraview, parse
    RAS2D mesh information and convert/save to SRH-2D format, query RAS2D
    results (e.g., for calibration), etc.
    
    Attributes
    ----------
    hdf_filename : str
        the name for the HDF result file generated by HEC-RAS
    plan_filename : str
        the name for the HEC-RAS run plan file
    plan : str
        the name of the HEC-RAS run plan
    short_identifier : str
        the short name of the run, called "Short Identifier" in HEC-RAS
    
    
    Methods
    -------
    get_units()    
        Get the units used in the HEC-RAS project
    
    """
    
    def __init__(self, hdf_filename, terrain_filename):
        self.hdf_filename = hdf_filename
        self.plan_filename = hdf_filename[:-4]
        self.plan = self.plan_filename[-3:]
        self.short_identifier = "Short Identifier="
        self.project_filename = self.plan_filename[:-4] + '.prj'
        self.terrain_filename = terrain_filename
        
        #number of points for each face's profile (subgrid terrain)
        #HEC-RAS's HDF file does not export face profile, although in RAS Mapper
        #the face profile can be plotted and tabulated. It is not clear how these face 
        #profiles are created. Here, we use a uniformed sampled terrain points on each face line.
        self.nFaceProfilePoints = 20
        
        self.comp_interval = ''
        self.outp_interval = ''
        self.map_interval = ''
        
        #get intervals
        self.get_intervals()
        
        self.units = ''
        self.short_ID = ''
        
        #get units
        self.get_units()
        
        #get short_ID
        self.get_shortID()
        
        self.start_time = ''
        self.end_time = ''
        self.Dpart = ''
        
        #get start and end times
        self.get_start_end_time()
        
        #get solution time series 
        self.solution_time = self.get2DAreaSolutionTimes()
        self.solution_time_date = self.get2DAreaSolutionTimeDates() 
        
        self.TwoDAreaNames = []
        
        #get 2D Area names
        self.get2DAreaNames()
        
        self.TwoDAreaCellCounts = []
        
        #get 2D area cell count
        self.get2DAreaCellCounts()
        
        #get 2D area cell points
        self.TwoDAreaCellPoints = self.get2DAreaCellPoints()
        
        #get 2D ara boundary points
        self.TwoDAreaBoundaryPoints = self.get2DAreaBoundaryPoints()
        
        #build boundaries
        self.totalBoundaries, self.boundaryTotalPoints, self.boundaryPointList = self.build2DAreaBoundaries()
        
        #get 2D area cell face points indexes
        #self.TwoDAreaCellFacePointsIndexes = self.get2DAreaCellFacePointsIndexes()
        
        #interpolator for elevation (bathymetry)
        self.bilinterp = self.build2DElevationInterpolator()
        
        #2D area face area elevation info and values
        self.TwoDAreaFaceAreaElevationInfo = []
        self.TwoDAreaFaceAreaElevationValues = []
        
        #list to store face hydraulic information: a list of lists
        self.TwoDAreaFaceHydraulicInformation = self.build2DAreaFaceHydraulicInformation()
        
        #list to store cell face list: a list of lists
        #e.g., TwoDAreaCellFaceList[0][1] is a list of faces for cell 1 in 2D flow area 0
        self.TwoDAreaCellFaceList = []

        #build TwoDAreaCellFaceList
        self.build2DAreaCellFaceList()
        
        #2D area Manning's n at cell center: a list for all 2D areas
        #e.g., TwoDAreaCellManningN[0][1] is the Manning's n value for cell 1 in 2D flow area 0
        self.TwoDAreaCellManningN = []
        
        #interpolte Manning's n from face to cell center: TwoDAreaCellManningN 
        self.interpolateManningN_face_to_cell()
        
        #list to store face's two FacePoints
        #e.g., TwoDAreaFace_FacePoints[0][1] is a list two FacePoint IDs for face 1 in 2D flow area 0
        self.TwoDAreaFace_FacePoints = []
        
        #build TwoDAreaFace_FacePoints
        self.buildFace_FacePoints()
        
        #list to store face profile (subgrid terrain). On each face, number of points is self.nFaceProfilePoints.
        #e.g., TwoDAreaFaceProfile[0][1][0:nFaceProfilePoints,3] stores the profile for face 1 in 2D flow area 0
        self.TwoDAreaFaceProfile = []
        
        #build face profile
        self.build2DAreaFaceProfile()
        
        #meshio object list (each 2D area corresponding to one meshio object although only one 2D area is supported)
        self.meshioObjectList = []
        
        #build the meshio object list
        self.buildMeshioObjects()
        
        #By default, HEC-RAS 2D outputs the following time series solution data in HDF file
        #   - Depth (in each cell, including the ghost cells)
        #   - Node X Vel (node velocity in x-direction)
        #   - Node Y Vel (node velocity in y-direction)
        #   - Water Surface (water surface elevation in each cell, including the ghost cells)
        #   - other solution variables at face centers (don't know how to deal with them yet)
        # load solutions for 2D areas
        self.TwoDAreaCellDepth = []
        self.TwoDAreaCellWSE = []
        self.TwoDAreaPointVx = []
        self.TwoDAreaPointVy = []
        self.TwoDAreaPointVz = []
        
        self.load2DAreaSolutions()
        
        
    
    def get_units(self):    
        """Get the units used in the HEC-RAS project
        
        Units used in HEC-RAS can be either 'Feet' or 'Meter'.
        
        """
        
        # open the HEC-RAS project file
        with open(self.project_filename,'r') as project_file:
            lines = project_file.readlines()
            if "English Units" in lines[3]:
                self.units = 'Feet'
            elif "SI Units" in lines[3]:
                self.units = "Meter"
            else:
                self.units = "Unknown units"
 

    def get_shortID(self):
        """" Find the short_ID

        """
        with open(self.plan_filename,'r') as plan_file:
            for line in plan_file:
                if self.short_identifier in line:
                    self.shortID = line[line.index(self.short_identifier) + 
                                        len(self.short_identifier):].rpartition("\n")[0]
                    self.shortID = ' '.join(self.shortID.split())
                    break


    def get_intervals(self):
        """ Get the computation, output, and map intervals

        """
        comp_indicator = "Computation Interval="
        outp_indicator = "Output Interval="
        map_indicator = "Mapping Interval="
        
        i=0
        
        with open(self.plan_filename,'r') as plan_file:
            for line in plan_file:
                if comp_indicator in line:
                    self.comp_interval = line[line.index(comp_indicator) + 
                                              len(comp_indicator):].rpartition("\n")[0]
                    i += 1
                    if i==3:
                        break
                elif outp_indicator in line:
                    self.outp_interval = line[line.index(outp_indicator) + 
                                              len(outp_indicator):].rpartition("\n")[0]
                    i += 1
                    if i==3:
                        break
                elif map_indicator in line:
                    self.map_interval = line[line.index(map_indicator) + 
                                             len(map_indicator):].rpartition("\n")[0]
                    i += 1
                    if i==3:
                        break
         

    def get_time_minutes(self, interval):
        """ pass the interval to this function to get the minute value

        Parameters
        ----------
        interval

        Returns
        -------

        """
        interval_to_minutes = {'1MIN': 1, '2MIN':2,'3MIN':3,'4MIN':4,'5MIN':5,'10MIN':10,'15MIN':15,
                               '20MIN':20,'30MIN':30,'1HOUR':60}
        try:
            minutes = interval_to_minutes[interval]
        except:
            message = "You might need to modify the get_time_minutes() function so that there is a interval corresponding to your %s interval" %interval
            sys.exit(message)
            raise
        
        return minutes


    def get_start_end_time(self):
        """ Get the plan_filename and the start_time and end_time

        Returns
        -------

        """

        #print("plan_filename = ", self.plan_filename)
        time_indicator = "Simulation Date="
        with open(self.plan_filename,'r') as plan_file:
            for line in plan_file:
                if time_indicator in line:
                    time_line = line
                    break

        times = time_line[time_line.index(time_indicator) + len(time_indicator):]
        self.start_time = times[0:14]
        self.start_time = self.start_time.replace(","," ")
        self.end_time = times[15:]
        self.end_time = self.end_time.replace(","," ")
        self.Dpart = self.start_time[0:9]
        self.Dpart = list(self.Dpart)
        self.Dpart[0:2] = "01"
        self.Dpart = ''.join(self.Dpart)


    def get2DAreaNames(self):
        """ Get the names of 2D Flow Areas in the HEC-RAS Plan's geometry

        Returns
        -------

        """
        hf = h5py.File(self.hdf_filename,'r') 
        
        self.TwoDAreaNames = hf['Geometry']['2D Flow Areas']['Attributes']['Name']
        
        #hdf2DFlow = hf['Geometry']['2D Flow Areas']
        
        #for key in hdf2DFlow:
        #    if key in ['Attributes', 'Cell Info', 'Cell Points', 'Manning\'s n',\
        #           'Names', 'Polygon Info', 'Polygon Parts', 'Polygon Points',\
        #          'Tolerances']:
        #        continue
        #    else:
        #        self.TwoDAreaNames.append(key) # List of 2D Area names
        

    def get2DAreaCellCounts(self):
        """ Get 2D Flow Areas cell counts

        Returns
        -------

        """
        hf = h5py.File(self.hdf_filename,'r') 
        self.TwoDAreaCellCounts = hf['Geometry']['2D Flow Areas']['Attributes']['Cell Count']
            

    def get2DAreaCellPoints(self):
        """ Get 2D Flow Area cell points

        Returns
        -------

        """
        hf = h5py.File(self.hdf_filename,'r') 
        hdf2DAreaCellPoints = np.array(hf['Geometry']['2D Flow Areas']['Cell Points'])
        #print(hdf2DAreaCellPoints)
        return hdf2DAreaCellPoints
    

    def get2DAreaBoundaryPoints(self):
        """ Get 2D Flow Area boundary points (all points on boundaries)

        Returns
        -------

        """
        hf = h5py.File(self.hdf_filename,'r') 
        hdf2DAreaBoundaryPoints = np.array(hf['Geometry']['Boundary Condition Lines']['External Faces'])
        #print(hdf2DAreaBoundaryPoints)    
        return hdf2DAreaBoundaryPoints
    

    def build2DAreaBoundaries(self):
        """ Build boundaries with their point list

        Returns
        -------

        """
        print("Building HEC-RAS 2D area boundaries ...")
        maxNumBC = 3          #maximum number of boundaries (adjust according to the mesh)
        maxPointsPerBC = 20   #maximum number of points per boundary

        boundaryIDList = np.zeros(maxNumBC,dtype=int)   #list of boundary IDs
        boundaryPointList = np.zeros((maxNumBC,maxPointsPerBC),dtype=int)  #list of point IDs on each boundary
        boundaryTotalPoints = np.zeros(maxNumBC,dtype=int)    #total number of points in each boundary            

        #read the first row of BoundaryPoints
        totalBoundaries = 0                           #total number of boundaries
        currentBoundary = 0                           #current BC counter 
        pointCounterInCurrentBoundary = 0             #point counter in current boundary
        boundaryIDList[currentBoundary] = self.TwoDAreaBoundaryPoints[0][0]       #first BC Line ID
        boundaryPointList[currentBoundary,0] = self.TwoDAreaBoundaryPoints[0][2]  #first point
        boundaryPointList[currentBoundary,1] = self.TwoDAreaBoundaryPoints[0][3]  #second point
        pointCounterInCurrentBoundary = 2
        boundaryTotalPoints[currentBoundary] = 2
        totalBoundaries = 1

        #loop through row 2 to end of BoundaryPoints
        for k in range(self.TwoDAreaBoundaryPoints.shape[0]-1):
            if currentBoundary == self.TwoDAreaBoundaryPoints[k+1][0]: #still the old BC line
                boundaryPointList[currentBoundary,pointCounterInCurrentBoundary] = self.TwoDAreaBoundaryPoints[k+1][3] 
                pointCounterInCurrentBoundary += 1
                boundaryTotalPoints[currentBoundary] += 1
            else:                                        #a new BC line
                totalBoundaries += 1
                currentBoundary += 1
                boundaryIDList[currentBoundary] = self.TwoDAreaBoundaryPoints[k+1][0]       #BC Line ID
                boundaryPointList[currentBoundary,0] = self.TwoDAreaBoundaryPoints[k+1][2]  #first point
                boundaryPointList[currentBoundary,1] = self.TwoDAreaBoundaryPoints[k+1][3]  #second point
                pointCounterInCurrentBoundary = 2
                boundaryTotalPoints[currentBoundary] = 2
        
        #print("Total number of boundaries: ", totalBoundaries)        
        #print("boundaryTotalPoints: ", boundaryTotalPoints)
        #print("boundaryPointList: ", boundaryPointList)
    
        return totalBoundaries, boundaryTotalPoints, boundaryPointList


    def build2DElevationInterpolator(self):
        """ Build the interpolator for elevation at points

        Returns
        -------

        """
        print('Building 2D elevation interpolator ...')
        # Read raster
        #print(terrainFileName)
        source = gdal.Open(self.terrain_filename)
        #print(source)

        # Read the raster band as separate variable
        #band = source.GetRasterBand(1)

        # Print only selected metadata:
        #print ("[ NO DATA VALUE ] = ", band.GetNoDataValue()) # none
        #print ("[ MIN ] = ", band.GetMinimum())
        #print ("[ MAX ] = ", band.GetMaximum())

        nx, ny = source.RasterXSize, source.RasterYSize
        gt = source.GetGeoTransform()
        band_array = source.GetRasterBand(1).ReadAsArray().astype(np.float)

        # Compute mid-point grid spacings
        ax = np.array([gt[0] + ix*gt[1] + gt[1]/2.0 for ix in range(nx)])
        ay = np.array([gt[3] + iy*gt[5] + gt[5]/2.0 for iy in range(ny)])

        bilinterp = interpolate.interp2d(ax, ay, band_array, kind='linear')
    
        return bilinterp
        

    def get2DAreaCellFacePointsIndexes(self, area):
        """ Get 2D Flow Area cell face points indexes for a specified 2D area

        Parameters
        ----------
        area

        Returns
        -------

        """
        hf = h5py.File(self.hdf_filename,'r') 
        hdf2DAreaCellFacePointsIndexes = np.array(hf['Geometry']['2D Flow Areas'][area]
                                                   ['Cells FacePoint Indexes'])
        #print(hdf2DAreaCellFacePointsIndexes)
        return hdf2DAreaCellFacePointsIndexes


    def get2DAreaFacePointsCoordinates(self, area):
        """ Get the face points' coordinates for a specified 2D area

        Parameters
        ----------
        area

        Returns
        -------

        """
        hf = h5py.File(self.hdf_filename,'r') 
        hdf2DAreaFacePointsCoordinates = np.array(hf['Geometry']['2D Flow Areas'][area]['FacePoints Coordinate'])
        
        #print(hdf2DAreaFacePointsCoordinates)
        
        #add the third column to the coordinates array for the z-coordinates (RAS2D only exports x and y, not z)
        z_temp = np.zeros(hdf2DAreaFacePointsCoordinates.shape[0])
        
        hdf2DAreaFacePointsCoordinates3D = np.column_stack((hdf2DAreaFacePointsCoordinates, z_temp))
        
        #interpolate the elevation (bathymetry) to z coordinates
        self.interpolateZcoord2Points(hdf2DAreaFacePointsCoordinates3D)
        
        #print(hdf2DAreaFacePointsCoordinates3D)
        
        return hdf2DAreaFacePointsCoordinates3D
    

    def interpolateZcoord2Points(self, facePointsCoordinates3D):
        """ Interpolate the elevation (bathymetry) to 2D area's points (z-coordinate)

        Parameters
        ----------
        facePointsCoordinates3D

        Returns
        -------

        """
        for k in range(facePointsCoordinates3D.shape[0]):
            x1 = facePointsCoordinates3D[k,0]
            y1 = facePointsCoordinates3D[k,1]
        
            #print(nx, ny, x1,y1,bilinterp(x1,y1))
            facePointsCoordinates3D[k,2] = self.bilinterp(x1,y1)


    def get2DAreaCellsFaceOrientationInfo(self, area):
        """ Get cells face and orientation info for a specified 2D area

        Parameters
        ----------
        area

        Returns
        -------

        """
        hf = h5py.File(self.hdf_filename,'r') 
        hdf2DAreaCellsFaceOrientationInfo = np.array(hf['Geometry']['2D Flow Areas'][area]['Cells Face and Orientation Info'])
        #print(hdf2DAreaCellsFaceOrientationInfo)    
        return hdf2DAreaCellsFaceOrientationInfo


    def get2DAreaCellsFaceOrientationValues(self, area):
        """ Get cells face and orientation values for a specified 2D area

        Parameters
        ----------
        area

        Returns
        -------

        """
        hf = h5py.File(self.hdf_filename,'r') 
        hdf2DAreaCellsFaceOrientationValues = np.array(hf['Geometry']['2D Flow Areas'][area]['Cells Face and Orientation Values'])
        #print(hdf2DAreaCellsFaceOrientationValues)    
        return hdf2DAreaCellsFaceOrientationValues    
    

    def get2DAreaFaceAreaElevationInfo(self, area):
        """ Get faces area elevation info for a specified 2D area

        Two columns: first column-starting index, second column-length of record

        Parameters
        ----------
        area

        Returns
        -------

        """
        hf = h5py.File(self.hdf_filename,'r') 
        hdf2DAreaFaceAreaElevationInfo = np.array(hf['Geometry']['2D Flow Areas'][area]['Faces Area Elevation Info'])
        #print(hdf2DAreaFaceAreaElevationInfo)    
        return hdf2DAreaFaceAreaElevationInfo    
    

    def get2DAreaFaceAreaElevationValues(self, area):
        """ Get faces area elevation values for a specified 2D area

        Four columns: first column-elevation, second column-area
                     third column-wetted perimeter, fourth column-Manning's n (a constant as of now RAS version <=6)

        Parameters
        ----------
        area

        Returns
        -------

        """
        hf = h5py.File(self.hdf_filename,'r') 
        hdf2DAreaFaceAreaElevationValues = np.array(hf['Geometry']['2D Flow Areas'][area]['Faces Area Elevation Values'])
        #print(hdf2DAreaFaceAreaElevationValues)    
        return hdf2DAreaFaceAreaElevationValues 
    

    def get2DAreaFaceFacePointIndexes(self, area):
        """ Get face's facepoint indexes (two interger IDs)

        Parameters
        ----------
        area

        Returns
        -------

        """

        hf = h5py.File(self.hdf_filename,'r') 
        hdf2DAreaFaceFacePointIndexes = np.array(hf['Geometry']['2D Flow Areas'][area]['Faces FacePoint Indexes'])
        #print(hdf2DAreaFaceFacePointIndexes)    
        return hdf2DAreaFaceFacePointIndexes  
    

    def hdf2DAreaResultVar(self, area, varName):
        """ Get HEC-RAS solution time series result for a given variable

        Parameters
        ----------
        area
        varName

        Returns
        -------

        """
        hf = h5py.File(self.hdf_filename,'r') 
        hdf2DAreaResultVar = np.array(hf['Results']['Unsteady']['Output']['Output Blocks']
                  ['Base Output']['Unsteady Time Series']['2D Flow Areas'][area][varName])
        
        #only take the last row (time step)
        #hdf2DAreaResultVar = hdf2DAreaResultVar[(hdf2DAreaResultVar.shape[0]-1)]
        #print(varName, hdf2DAreaResultVar)    
        return hdf2DAreaResultVar
    

    def get2DAreaSolutionTimes(self):
        """ Get 2D Flow Area solution times

        Returns
        -------

        """
        hf = h5py.File(self.hdf_filename,'r') 
        hdf2DAreaSolutionTimes = np.array(hf['Results']['Unsteady']['Output']['Output Blocks']
                  ['Base Output']['Unsteady Time Series']['Time'])
        #print(hdf2DAreaSolutionTimes)
        return hdf2DAreaSolutionTimes
    

    def get2DAreaSolutionTimeDates(self):
        """ Get 2D Flow Area solution time_dates

        Returns
        -------

        """
        hf = h5py.File(self.hdf_filename,'r') 
        hdf2DAreaSolutionTimeDates = np.array(hf['Results']['Unsteady']['Output']['Output Blocks']
                  ['Base Output']['Unsteady Time Series']['Time Date Stamp'])
        #print(hdf2DAreaSolutionTimeDates)
        return hdf2DAreaSolutionTimeDates


    def load2DAreaSolutions(self):
        """ # Load solutions (cell depth and water surface elevation, node X and Y vel.) for all 2D areas

        Returns
        -------

        """
        print('Loading 2D area solutions ...')
        #loop through each 2D areas
        for area,i in zip(self.TwoDAreaNames, range(len(self.TwoDAreaNames))):
            #print("2D Flow Area = ", area)
            
            #fetch the depth and WSE data
            cellDepth = self.hdf2DAreaResultVar(area, 'Depth')
            cellWSE = self.hdf2DAreaResultVar(area, 'Water Surface')
            
            #slice the cell data array to get values only for cells in current 2D area. 
            #The HEC-RAS results also contain values at the center of boundary faces.
            cellDepth = cellDepth[0:(self.TwoDAreaCellCounts[i])]
            cellWSE = cellWSE[0:(self.TwoDAreaCellCounts[i])]

            self.TwoDAreaCellDepth.append(cellDepth)
            self.TwoDAreaCellWSE.append(cellWSE)
            
            #fetch point data
            #Node X Vel and Node Y Vel
            pointVx=self.hdf2DAreaResultVar(area, 'Node X Vel')
            pointVy=self.hdf2DAreaResultVar(area, 'Node Y Vel')
            
            self.TwoDAreaPointVx.append(pointVx)
            self.TwoDAreaPointVy.append(pointVy)
            self.TwoDAreaPointVz.append(pointVx*0.0) #fake z velocity (=0)


    def assembleVectors(self, pointVx, pointVy, pointVz):
        """ Assemble vectors from their components and return the array

        Parameters
        ----------
        pointVx
        pointVy
        pointVz

        Returns
        -------

        """
   
        assert(len(pointVx)==len(pointVy))
    
        V = np.zeros((len(pointVx),3))
    
        for i in np.arange(len(pointVx)):
            #print(i,V[i,0],pointVx[i])
            V[i,0] = pointVx[i]
            V[i,1] = pointVy[i]
            V[i,2] = pointVz[i]
    
        return V

    def build2DAreaFaceHydraulicInformation(self):
        """ For 2D flow area, build face hydraulic information table (face area elevation)

        Returns
        -------

        """
        print("Building 2D area's face hydraulic information ...")

        areaFaceHydraulicInformationTable = []

        #loop through each 2D areas
        for area,i in zip(self.TwoDAreaNames, range(len(self.TwoDAreaNames))):
            #print("2D Flow Area = ", area)
            
            #get face area elevation info
            faceAreaElevationInfo = self.get2DAreaFaceAreaElevationInfo(area)
            
            self.TwoDAreaFaceAreaElevationInfo.append(faceAreaElevationInfo)
            
            #get face area elevation values
            faceAreaElevationValues = self.get2DAreaFaceAreaElevationValues(area)
            
            self.TwoDAreaFaceAreaElevationValues.append(faceAreaElevationValues)
            
            #print("Total number of faces in this area: ", faceAreaElevationInfo.shape[0])
            
            #temp list to store the numpy arrays (tables) for each face in current area
            currAreaFaceHydraulicInformationTable = []
            
            #loop through all faces in this area
            for faceI in range(faceAreaElevationInfo.shape[0]):
                #print("faceI = ", faceI)
                
                faceData = np.zeros([faceAreaElevationInfo[faceI,1],4]) #the four columns: elevation, area, wetted perimeter, and Manning's n
                
                start_row = faceAreaElevationInfo[faceI,0]
                end_row = faceAreaElevationInfo[faceI,0] + faceAreaElevationInfo[faceI,1]
                
                faceData = faceAreaElevationValues[start_row:end_row,:].copy() #make a copy
                #print("faceData = ", faceData)
                
                currAreaFaceHydraulicInformationTable.append(faceData)                
            
            #append the current area's faceHydraulicInformation table to the top list
            areaFaceHydraulicInformationTable.append(currAreaFaceHydraulicInformationTable)
            
            return areaFaceHydraulicInformationTable
                
            
            

    def build2DAreaCellFaceList(self):
        """ Build cell's face list

        Returns
        -------

        """
        print("Building 2D area's cell face list ...")

        #loop through each 2D areas
        for area,i in zip(self.TwoDAreaNames, range(len(self.TwoDAreaNames))):
            #print("2D Flow Area = ", area)

            #get cells face and orientation info
            cellsFaceOrientationInfo = self.get2DAreaCellsFaceOrientationInfo(area)
                
            #get cells face and orientation values
            cellsFaceOrientationValues = self.get2DAreaCellsFaceOrientationValues(area)
            
            #temp list to store the numpy arrays (face list) for each cell in current area
            currAreaCellFaceList = []
            
            #loop through cells in current area
            for cellI in range(self.TwoDAreaCellCounts[i]):
                start_row = cellsFaceOrientationInfo[cellI,0]
                end_row = cellsFaceOrientationInfo[cellI,0] + cellsFaceOrientationInfo[cellI,1]
                
                faceList = cellsFaceOrientationValues[start_row:end_row,0].copy() #make a copy
                #print("faceList =", faceList)
                
                currAreaCellFaceList.append(faceList)
                
            #append the current area's cell face list to the top list
            self.TwoDAreaCellFaceList.append(currAreaCellFaceList)


    def horizontalDistance(self, point1, point2):
        """ Horizontal distance between two points

        Parameters
        ----------
        point1
        point2

        Returns
        -------

        """
        return np.sqrt(np.square(point2[0] - point1[0]) + np.square(point2[1] - point1[1]))
                

    def build2DAreaFaceProfile(self):
        """ Build face profile

        Returns
        -------

        """
        print("Building 2D area's face profile ...")

        #loop through each 2D areas
        for area,i in zip(self.TwoDAreaNames, range(len(self.TwoDAreaNames))):
            #print("2D Flow Area = ", area)
            
            face_facePoints = self.TwoDAreaFace_FacePoints[i]
            
            #get the FacePoint coordinates in the current 2D flow area
            facePointsCoordinates = self.get2DAreaFacePointsCoordinates(area)
            
            curAreaProfilePoints = []
            
            #loop through all faces in current area
            for faceI in range(face_facePoints.shape[0]):
                #print("faceI =", faceI)
                facePoint_start = face_facePoints[faceI,0]  #start ID of facePoint
                facePoint_end = face_facePoints[faceI,1]    #end ID of facePoint
                
                #get the coordinates of the start and end facePoints
                startFacePointCoordinates = facePointsCoordinates[facePoint_start]
                endFacePointCoordinates = facePointsCoordinates[facePoint_end]
                
                length = self.horizontalDistance(startFacePointCoordinates,endFacePointCoordinates)
                
                stations = np.linspace(0,length,self.nFaceProfilePoints,endpoint=True)
                
                #if faceI == 0: print(repr(stations))
                
                #print(startFacePointCoordinates)
                #print(endFacePointCoordinates)
                
                #create the array for the coordinates of all points on the profile 
                #(x,y,z)
                profilePoints = np.zeros((self.nFaceProfilePoints,3))
                
                for pointI in range(self.nFaceProfilePoints):
                    profilePoints[pointI,:] = (startFacePointCoordinates + (endFacePointCoordinates-startFacePointCoordinates)
                                           *pointI/(self.nFaceProfilePoints-1))
                    
                #if faceI == 0: print(repr(profilePoints))
                    
                self.interpolateZcoord2Points(profilePoints)
                
                #if faceI == 0: print(repr(profilePoints))    
                
                curAreaProfilePoints.append(profilePoints)
                
                
            self.TwoDAreaFaceProfile.append(curAreaProfilePoints)
            

    def interpolateManningN_face_to_cell(self):
        """ interpolate Manning's n from face to cell center
        HEC-RAS 2D stores Manning's n value at faces, not cell centers. We need to
        interpolate its value from face to cell center. Another option is to use the
        cell center coordinates and direclty query the Manning's n layer in RAS Mapper, which
        might be too complicated because HEC-RAS has default Manning's n, Land Use Cover, Override polygon, etc.
        Here, the interpolation from face to cell might not be a bad choice.

        For each face, HEC-RAS currently does not support varying Manning's n (horizontally and veritcally). Thus,
        effectively, it is a constant value for each face. This may change in the future.

        Returns
        -------

        """
        print("Interpolating Manning's n from face to cell center ...")
        
        #loop through each 2D areas
        for area,i in zip(self.TwoDAreaNames, range(len(self.TwoDAreaNames))):
            #print("2D Flow Area = ", area)
            
            temp_n = np.zeros(self.TwoDAreaCellCounts[i])
            
            #loop through cells in current area
            for cellI in range(self.TwoDAreaCellCounts[i]):
                temp_n[cellI] = self.TwoDAreaFaceHydraulicInformation[i][cellI][0,3] #only take the first value because it is constant for each face
                
            self.TwoDAreaCellManningN.append(temp_n)

    #build face's facepoint list
    def buildFace_FacePoints(self):
        print("Building face's facepoints list ...")
        
        #loop through each 2D areas
        for area,i in zip(self.TwoDAreaNames, range(len(self.TwoDAreaNames))):
            #print("2D Flow Area = ", area)

            #get cells face and orientation info
            faceFacePointIndexes = self.get2DAreaFaceFacePointIndexes(area)
            
            self.TwoDAreaFace_FacePoints.append(faceFacePointIndexes)
                    
            

    def saveHEC_RAS2D_results_to_VTK(self,timeStep=-1,lastTimeStep=False):
        """ Save HEC-RAS 2D solutions to VTK files.

        Note:
           - Each area saved separately
           - Each time saved separately
        The resulted files will be RAS2D_areaName_timeSequence.vtk, e.g.,
        RAS2D_SpringCreek_0001.vtk, RAS2D_SpringCreek_0002.vtk, etc.

        The option lastTimeStep specifies whether only the last time step is saved (default=False).
        The option timeStep specifies the particular step to be saved.
        If both lastTimeSTep and timeStep are specified, lastTimeStep has the priority.

        Parameters
        ----------
        timeStep
        lastTimeStep

        Returns
        -------

        """
        print('Saving RAS2D results to VTK ...')
        
        #check the sanity of timeStep
        if (timeStep != -1) and (not timeStep in range(len(self.solution_time))):
            message = "Specified timeStep = %d not in range (0 to %d)." % (timeStep, len(self.solution_time))
            sys.exit(message)
        
        #loop through each 2D areas
        for area,i in zip(self.TwoDAreaNames, range(len(self.TwoDAreaNames))):
            #print("2D Flow Area = ", area)
            
            #get the FacePoint indexes
            cellFacePointIndexes = self.get2DAreaCellFacePointsIndexes(area)
    
            #get the FacePoint coordinates
            facePointsCoordinates = self.get2DAreaFacePointsCoordinates(area)
    
            #get cells face and orientation info
            cellsFaceOrientationInfo = self.get2DAreaCellsFaceOrientationInfo(area)
            
            #get current 2D area's solutions
            cellDepth = self.TwoDAreaCellDepth[i]
            cellWSE = self.TwoDAreaCellWSE[i]
            pointVx = self.TwoDAreaPointVx[i]
            pointVy = self.TwoDAreaPointVy[i]
            pointVz = self.TwoDAreaPointVz[i]
            
            #add Manning's n value for visualization
            cellManningN = self.TwoDAreaCellManningN[i]
            
            #print("self.TwoDAreaCellDepth = ", self.TwoDAreaCellDepth)
            #print("type(cellDepth) =", type(cellDepth))
            #print("cellDepth =", cellDepth)
            
            #loop through solution times 
            for timeI in range(len(self.solution_time)):
                
                if lastTimeStep:
                    if timeI < (len(self.solution_time)-1):
                        continue
                    
                if (timeStep != -1) and (timeI != timeStep):
                    continue
                
                print("timeI = ", timeI)
                
                #loop through each cell in the current 2D area
                #lists to store the point indexes of cells of different shapes
                tri_pointIndexes_list = []
                quad_pointIndexes_list = []
                polygon5_pointIndexes_list = []
                polygon6_pointIndexes_list = []
                polygon7_pointIndexes_list = []
                polygon8_pointIndexes_list = []    
    
                #lists to store the cell center results
                tri_cellDepth_list = []
                quad_cellDepth_list = []
                polygon5_cellDepth_list = []
                polygon6_cellDepth_list = []
                polygon7_cellDepth_list = []
                polygon8_cellDepth_list = []    
    
                tri_cellWSE_list = []
                quad_cellWSE_list = []
                polygon5_cellWSE_list = []
                polygon6_cellWSE_list = []
                polygon7_cellWSE_list = []
                polygon8_cellWSE_list = []
                
                tri_ManningN_list = []
                quad_ManningN_list = []
                polygon5_ManningN_list = []
                polygon6_ManningN_list = []
                polygon7_ManningN_list = []
                polygon8_ManningN_list = []
    
                for celli in range(self.TwoDAreaCellCounts[i]):
                    #get the number of face points (=number of faces)
                    numFP = cellsFaceOrientationInfo[celli,1]
                    #print("numFP = ", numFP)
        
                    if numFP==3:  #triangle, only has 3 points
                        #print("trinalge")
                        tri_pointIndexes_list.append(cellFacePointIndexes[celli][0:3])
                        tri_cellDepth_list.append(cellDepth[timeI,:][celli])
                        tri_cellWSE_list.append(cellWSE[timeI,:][celli])
                        tri_ManningN_list.append(cellManningN[celli])
                    elif numFP == 4:  #quad
                        #print("quad")
                        quad_pointIndexes_list.append(cellFacePointIndexes[celli][0:4])
                        #print("cellDepth[timeI,:] = ", cellDepth[timeI,:])
                        #print("cellDepth[timeI,:][celli] = ", cellDepth[timeI,:][celli])
                        quad_cellDepth_list.append(cellDepth[timeI,:][celli])
                        quad_cellWSE_list.append(cellWSE[timeI,:][celli])
                        quad_ManningN_list.append(cellManningN[celli])
                    elif numFP == 5:  #polygon5
                        #print("polygon5")
                        polygon5_pointIndexes_list.append(cellFacePointIndexes[celli][0:5])
                        polygon5_cellDepth_list.append(cellDepth[timeI,:][celli])
                        polygon5_cellWSE_list.append(cellWSE[timeI,:][celli])
                        polygon5_ManningN_list.append(cellManningN[celli])
                    elif numFP == 6:  #polygon6
                        #print("polygon6")
                        polygon6_pointIndexes_list.append(cellFacePointIndexes[celli][0:6])
                        polygon6_cellDepth_list.append(cellDepth[timeI,:][celli])
                        polygon6_cellWSE_list.append(cellWSE[timeI,:][celli])
                        polygon6_ManningN_list.append(cellManningN[celli])
                    elif numFP == 7:  #polygon7
                        #print("polygon7")
                        polygon7_pointIndexes_list.append(cellFacePointIndexes[celli][0:7])
                        polygon7_cellDepth_list.append(cellDepth[timeI,:][celli])
                        polygon7_cellWSE_list.append(cellWSE[timeI,:][celli])
                        polygon7_ManningN_list.append(cellManningN[celli])
                    elif numFP == 8:  #polygon8
                        #print("polygon8")
                        polygon8_pointIndexes_list.append(cellFacePointIndexes[celli][0:8])
                        polygon8_cellDepth_list.append(cellDepth[timeI,:][celli])
                        polygon8_cellWSE_list.append(cellWSE[timeI,:][celli])   
                        polygon8_ManningN_list.append(cellManningN[celli])
                    else:
                        print("The cell shape is not supported")
            
                #convert the list to numpy array
                tri_pointIndexes = np.array(tri_pointIndexes_list)
                quad_pointIndexes = np.array(quad_pointIndexes_list)
                polygon5_pointIndexes = np.array(polygon5_pointIndexes_list)
                polygon6_pointIndexes = np.array(polygon6_pointIndexes_list)   
                polygon7_pointIndexes = np.array(polygon7_pointIndexes_list)
                polygon8_pointIndexes = np.array(polygon8_pointIndexes_list)
    
                tri_cellDepth = np.array(tri_cellDepth_list)
                quad_cellDepth = np.array(quad_cellDepth_list)
                polygon5_cellDepth = np.array(polygon5_cellDepth_list)
                polygon6_cellDepth = np.array(polygon6_cellDepth_list)
                polygon7_cellDepth = np.array(polygon7_cellDepth_list)
                polygon8_cellDepth = np.array(polygon8_cellDepth_list)
    
                tri_cellWSE = np.array(tri_cellWSE_list)
                quad_cellWSE = np.array(quad_cellWSE_list)
                polygon5_cellWSE = np.array(polygon5_cellWSE_list)
                polygon6_cellWSE = np.array(polygon6_cellWSE_list)
                polygon7_cellWSE = np.array(polygon7_cellWSE_list)
                polygon8_cellWSE = np.array(polygon8_cellWSE_list)
    
                tri_cellElev = tri_cellWSE - tri_cellDepth
                quad_cellElev = quad_cellWSE - quad_cellDepth
                polygon5_cellElev = polygon5_cellWSE - polygon5_cellDepth
                polygon6_cellElev = polygon6_cellWSE - polygon6_cellDepth
                polygon7_cellElev = polygon7_cellWSE - polygon7_cellDepth
                polygon8_cellElev = polygon8_cellWSE - polygon8_cellDepth
                
                tri_ManningN = np.array(tri_ManningN_list)
                quad_ManningN = np.array(quad_ManningN_list)
                polygon5_ManningN = np.array(polygon5_ManningN_list)
                polygon6_ManningN = np.array(polygon6_ManningN_list)
                polygon7_ManningN = np.array(polygon7_ManningN_list)
                polygon8_ManningN = np.array(polygon8_ManningN_list)                
                
                #print("quad_pointIndexes = ", quad_pointIndexes)
                #print('len(quad_pointIndexes) = ',len(quad_pointIndexes))
                
                #define the cells dictionary
                cellsDict = dict()
                if len(tri_pointIndexes)!=0:
                    cellsDict.update({'triangle' : tri_pointIndexes})   
        
                if len(quad_pointIndexes)!=0:
                    cellsDict.update({'quad' : quad_pointIndexes})    
        
                if len(polygon5_pointIndexes)!=0:
                    cellsDict.update({'polygon5' : polygon5_pointIndexes})       
        
                if len(polygon6_pointIndexes)!=0:
                    cellsDict.update({'polygon6' : polygon6_pointIndexes})  
        
                if len(polygon7_pointIndexes)!=0:
                    cellsDict.update({'polygon7' : polygon7_pointIndexes})    
        
                if len(polygon8_pointIndexes)!=0:
                    cellsDict.update({'polygon8' : polygon8_pointIndexes})   

                #print(cellsDict)
        
                #create the mesh without any data
                hec_ras_mesh = meshio.Mesh(facePointsCoordinates,cellsDict)
                
                #add data to the meshio mesh
    
                #add cell center scalar data
                #cellDataDict = {}
    
                #cell water depth
                #concatenate cell depth numpy arrays into one
                all_cellDepth = np.concatenate([tri_cellDepth, quad_cellDepth, polygon5_cellDepth, 
                                                polygon6_cellDepth, polygon7_cellDepth, polygon8_cellDepth])
                cellDataDict = {'depth': all_cellDepth}
    
                #print(cellDataDict)
                #print("all_cellDepth =", all_cellDepth)
    
                #cell WSE
                all_cellWSE = np.concatenate([tri_cellWSE, quad_cellWSE, polygon5_cellWSE, 
                                              polygon6_cellWSE, polygon7_cellWSE, polygon8_cellWSE])
                cellDataDict['WSE'] = all_cellWSE
    
                #cell center elevation
                all_cellElev = np.concatenate([tri_cellElev, quad_cellElev, polygon5_cellElev, 
                                               polygon6_cellElev, polygon7_cellElev, polygon8_cellElev])
                cellDataDict['Elev'] = all_cellElev
                    
                hec_ras_mesh.cell_data = cellDataDict
                
                #cell center Manning's n
                all_cellManningN = np.concatenate([tri_ManningN, quad_ManningN, polygon5_ManningN, 
                                                polygon6_ManningN, polygon7_ManningN, polygon8_ManningN])
                cellDataDict['ManningN'] = all_cellManningN
                
                #print(hec_ras_mesh.cell_data)
                
                # add point data
                
                pVel3D = self.assembleVectors(pointVx[timeI,:], pointVy[timeI,:], pointVz[timeI,:])
                #print(pVel3D)
    
                print("Add velocity to pointDataDict.")
                pointDataDict = {'Node_Velocity': pVel3D}
                
                hec_ras_mesh.point_data = pointDataDict
    
                #add field data: 
                #    - Time (float)
                #    - Time_Date (string)
                #field_data = {'TIME': np.array([self.solution_time[timeI]]), 'DATE_TIME': str(self.solution_time_date[timeI],'utf-8')}
                field_data = {'TIME': np.array([self.solution_time[timeI]])}
                
                hec_ras_mesh.field_data = field_data
                
                #write to vtk file
                fileName_temp = ['RAS2D_', area.astype(str), '_', str(timeI).zfill(4),'.vtk']
                vtkFileName = "".join(fileName_temp)
                meshio.write(vtkFileName,hec_ras_mesh,"vtk",binary=False)


    def buildMeshioObjects(self):
        """ Build meshio objects for each 2D areas in the RAS2D mesh (although for now only one 2D area is supported)

        Returns
        -------

        """
        print("Building meshio objects ...")
        #loop through each 2D areas
        for area,i in zip(self.TwoDAreaNames, range(len(self.TwoDAreaNames))):
            #print("2D Flow Area = ", area)
            
            #get the FacePoint indexes
            cellFacePointIndexes = self.get2DAreaCellFacePointsIndexes(area)
    
            #get the FacePoint coordinates
            facePointsCoordinates = self.get2DAreaFacePointsCoordinates(area)
    
            #get cells face and orientation info
            cellsFaceOrientationInfo = self.get2DAreaCellsFaceOrientationInfo(area)
            
                
            #loop through each cell in the current 2D area
            #lists to store the point indexes of cells of different shapes
            tri_pointIndexes_list = []
            quad_pointIndexes_list = []
            polygon5_pointIndexes_list = []
            polygon6_pointIndexes_list = []
            polygon7_pointIndexes_list = []
            polygon8_pointIndexes_list = []    
    
            for celli in range(self.TwoDAreaCellCounts[i]):
                #get the number of face points (=number of faces)
                numFP = cellsFaceOrientationInfo[celli,1]
                #print("numFP = ", numFP)
        
                if numFP==3:  #triangle, only has 3 points
                    #print("trinalge")
                    tri_pointIndexes_list.append(cellFacePointIndexes[celli][0:3])
                elif numFP == 4:  #quad
                    #print("quad")
                    quad_pointIndexes_list.append(cellFacePointIndexes[celli][0:4])
                elif numFP == 5:  #polygon5
                    #print("polygon5")
                    polygon5_pointIndexes_list.append(cellFacePointIndexes[celli][0:5])
                elif numFP == 6:  #polygon6
                    #print("polygon6")
                    polygon6_pointIndexes_list.append(cellFacePointIndexes[celli][0:6])
                elif numFP == 7:  #polygon7
                    #print("polygon6")
                    polygon7_pointIndexes_list.append(cellFacePointIndexes[celli][0:7])
                elif numFP == 8:  #polygon8
                    #print("polygon6")
                    polygon8_pointIndexes_list.append(cellFacePointIndexes[celli][0:8])
                else:
                    print("The cell shape is not supported")
            
            #convert the list to numpy array
            tri_pointIndexes = np.array(tri_pointIndexes_list)
            quad_pointIndexes = np.array(quad_pointIndexes_list)
            polygon5_pointIndexes = np.array(polygon5_pointIndexes_list)
            polygon6_pointIndexes = np.array(polygon6_pointIndexes_list)   
            polygon7_pointIndexes = np.array(polygon7_pointIndexes_list)
            polygon8_pointIndexes = np.array(polygon8_pointIndexes_list)
                
            #print("quad_pointIndexes = ", quad_pointIndexes)
            #print('len(quad_pointIndexes) = ',len(quad_pointIndexes))
                
            #define the cells dictionary
            cellsDict = dict()
            if len(tri_pointIndexes)!=0:
                cellsDict.update({'triangle' : tri_pointIndexes})   
        
            if len(quad_pointIndexes)!=0:
                cellsDict.update({'quad' : quad_pointIndexes})    
        
            if len(polygon5_pointIndexes)!=0:
                cellsDict.update({'polygon5' : polygon5_pointIndexes})       
        
            if len(polygon6_pointIndexes)!=0:
                cellsDict.update({'polygon6' : polygon6_pointIndexes})  
        
            if len(polygon7_pointIndexes)!=0:
                cellsDict.update({'polygon7' : polygon7_pointIndexes})    
        
            if len(polygon8_pointIndexes)!=0:
                cellsDict.update({'polygon8' : polygon8_pointIndexes})   

            #print(cellsDict)
        
            #create the mesh without any data
            hec_ras_mesh = meshio.Mesh(facePointsCoordinates,cellsDict)
            
            self.meshioObjectList.append(hec_ras_mesh)
                
            #write to vtk file (for debug)
            fileName_temp = ['RAS2D_meshonly_', area.astype(str),'_Area', str(i).zfill(4),'.vtk']
            vtkFileName = "".join(fileName_temp)
            meshio.write(vtkFileName,hec_ras_mesh,"vtk",binary=False)


    def exportSRHGEOMFile(self, srhgeomFileName):
        """ Export srhgeom file

        Parameters
        ----------
        srhgeomFileName

        Returns
        -------

        """
        #only the first 2D area is exported. 
        hec_ras_mesh = self.meshioObjectList[0]
        
        #write out to srhgeom file
        fname = srhgeomFileName + '.srhgeom'
        print("Writing SRHGEOM file: ", fname)
    
        try:
            fid = open(fname, 'w')
        except IOError:
            print('.srhgeom error')
            sys.exit()
    
        fid.write('SRHGEOM 30\n')
        fid.write('Name \"HEC-RAS 2D Mesh %s\"\n' % srhgeomFileName)
    
        fid.write('\n')
    
        fid.write('GridUnit \"%s\" \n' % self.units)        
        
        #all cells
        cell_id = 0   #cell ID counter
        for cell_type, data in hec_ras_mesh.cells:
            out = np.column_stack([np.full(data.shape[0], data.shape[1], dtype=data.dtype), data])
            #print(out.shape[0],out.shape[1])
        
            #for each cell in this block (type) of cells
            for row in out:
                cell_id += 1

                #replace the first number with the cell ID (counter)
                row[0] = cell_id
                #print(row)
            
                #HEC-RAS is 0-based; SRH-2D is 1-based. Thus "+1" for each point ID
                for k in range(len(row)-1):
                    row[k+1] += 1  
            
                #print(row)
                #print("\n")
            
            
                fid.write("Elem ")
                fid.write(" ".join(map(str, row)))
                fid.write("\n")
        
        #all points
        point_id = 0 #point ID counter
        for k in range(hec_ras_mesh.points.shape[0]):
            point_id += 1
            fid.write("Node %d " % point_id)
            fid.write(" ".join(map(str, hec_ras_mesh.points[k])))
            fid.write("\n")

        #NodeString    
        boundary_id = 0 #boundary ID counter
        for k in range(self.totalBoundaries):
            boundary_id += 1
            fid.write("NodeString %d " % boundary_id)
            fid.write(" ".join(map(str, self.boundaryPointList[boundary_id-1,:self.boundaryTotalPoints[boundary_id-1]]+1))) #all point IDs are +1 becaue SRH-2D is 1-based and RAS2D is 0-based.
            fid.write("\n")
        
        fid.close()
        

    def exportSRHMATFile(self, srhmatFileName):
        """ Export the SRHMAT file

        Parameters
        ----------
        srhmatFileName

        Returns
        -------

        """
        #only the first 2D area is exported. 
        hec_ras_mesh = self.meshioObjectList[0]       #mesh in meshio format
        cell_ManningN = self.TwoDAreaCellManningN[0]  #cell Manning's n
        
        print("cell_ManningN", cell_ManningN)
        
        #unique values of Mannings'n (one catch here is that in HEC-RAS different materials/zones may
        #have the same Manning's n. Here, it is impossible to differentiate them. But this does affect
        #simulation result.)
        #Here nIndices can be used as the Material ID
        uniqueManningN, nIndices = np.unique(cell_ManningN, return_inverse=True)
        
        #number of unique Manning's n values
        nUniqueManningN = uniqueManningN.shape[0]     
        
        print("uniqueManningN", uniqueManningN)
        print("nIndices", nIndices)
        print("nUniqueManningN", nUniqueManningN)
        
        fname = srhmatFileName + '.srhmat'
        print("Writing SRHMAT file: ", fname)
    
        try:
            fid = open(fname, 'w')
        except IOError:
            print('.srhmat error')
            sys.exit()
    
        fid.write('SRHMAT 30\n')
        fid.write('NMaterials %d\n' % nUniqueManningN)
        
        #output MatName
        for matID in range(nUniqueManningN):
            fid.write('MatName %d \"zone_%d\" \n' %(matID+1, matID+1))  #+1 because SRH-2D is 1-based
    
        #output cells in different material categories
        for matID in range(nUniqueManningN):
            fid.write('Material %d ' % (matID+1))
            
            #loop over all cells
            for celli in range(self.TwoDAreaCellCounts[0]):
                if abs(uniqueManningN[matID] - cell_ManningN[celli]) < 1e-4:
                    fid.write(" %d" % (celli+1))  #+1 because SRH-2D is 1-based
                    
                    if(((celli+1) % 10) == 0):  #10 numbers per line
                        fid.write("\n")
                
        fid.close()    


    def exportBoundariesToVTK(self, boundaryVTKFileName):
        """ Export boundaries of 2D area to VTK (for visual inspection in Paraview and check the ID of NodeString)

        Parameters
        ----------
        boundaryVTKFileName

        Returns
        -------

        """
        #only the boundaries of the first 2D area is exported.
        hec_ras_mesh = self.meshioObjectList[0]
        
        fname = boundaryVTKFileName + '.vtk'
        
        print('Writing RAS2D mesh boundaries to', fname)
        
        try:
            fid = open(fname, 'w')
        except IOError:
            print('boundary vtk file open error')
            sys.exit()
         
        #output header
        fid.write('# vtk DataFile Version 3.0\n')
        fid.write('RAS2D boundaries\n')
        fid.write('ASCII\n')
        fid.write('DATASET POLYDATA\n')
        fid.write('\n')
        
        #output all points in the mesh
        #(a short cut instead of output boundary points only; does not matter because
        #this is for inspection purpose only)
        
        #total number of points in mesh
        totalNumPoints = hec_ras_mesh.points.shape[0]
        
        fid.write('POINTS %d float\n' % totalNumPoints)

        #loop over all points
        for k in range(hec_ras_mesh.points.shape[0]):
            fid.write(" ".join(map(str, hec_ras_mesh.points[k])))
            fid.write("\n")
            
        #calculate total number of boundary points
        totalNumBoundaryPoints = 0
        for k in range(self.totalBoundaries):
            totalNumBoundaryPoints += self.boundaryTotalPoints[k]
            
        #print("totalNumBoundaryPoints = ", totalNumBoundaryPoints)
            
        #output lines (boundaries)
        fid.write('\nLINES %d %d\n' % (self.totalBoundaries, self.totalBoundaries+totalNumBoundaryPoints))
        
        for k in range(self.totalBoundaries):
            fid.write('%d ' % self.boundaryTotalPoints[k])
            fid.write(" ".join(map(str, self.boundaryPointList[k,:self.boundaryTotalPoints[k]])))
            fid.write("\n")
            
        #output line ID (as cell_data)
        fid.write('\nCELL_DATA %d \n' % self.totalBoundaries)
        fid.write('scalars BC_ID integer\n')
        fid.write('LOOKUP_TABLE default\n')
        
        for k in range(self.totalBoundaries):
            fid.write('%d ' % (k+1))   #here k+1 is because SRH-2D is 1-based and RAS2D is 0-based.
        
        fid.write('\n')
            
        fid.close()


    def exportFaceProfilesToVTK(self, faceProfileVTKFileName):
        """ Export face profile of 2D area to VTK (for visual inspection in Paraview)

        Parameters
        ----------
        faceProfileVTKFileName

        Returns
        -------

        """

        #only the face profiles of the first 2D area is exported.
        faceProfiles = self.TwoDAreaFaceProfile[0]
        
        fname = faceProfileVTKFileName + '.vtk'
        
        print('Writing all face profiles to', fname)     
        
        try:
            fid = open(fname, 'w')
        except IOError:
            print('face profile vtk file open error')
            sys.exit()
         
        #output header
        fid.write('# vtk DataFile Version 3.0\n')
        fid.write('RAS2D face profiles\n')
        fid.write('ASCII\n')
        fid.write('DATASET POLYDATA\n')
        fid.write('\n')
        
        #output all points in the profiles (repetition of points is ok because
        #this is for inspection purpose only)
        
        #total number of points in face profiles = (number of faces X points per profile)
        totalNumPoints = len(faceProfiles)*self.nFaceProfilePoints
        
        fid.write('POINTS %d float\n' % totalNumPoints)
        
        #loop over all points in all face profiles and export their coordinates
        for faceI in range(len(faceProfiles)):
            #loop over all points in current face profile
            for pointI in range(self.nFaceProfilePoints):
                #if pointI ==0: fid.write(" ".join(map(str, faceProfiles[faceI][pointI,:])))
                fid.write(" ".join(map(str, faceProfiles[faceI][pointI,:])))
                fid.write("\n")
        
        #output lines (face profiles)
        fid.write('\nLINES %d %d\n' % (len(faceProfiles), len(faceProfiles)+totalNumPoints))
        
        profileBase = np.arange(0,self.nFaceProfilePoints)
        
        currentLineStartingIndex = 0
        
        for lineI in range(len(faceProfiles)):
            fid.write('%d ' % self.nFaceProfilePoints)
            fid.write(" ".join(map(str, profileBase + currentLineStartingIndex)))
            fid.write("\n")
            
            currentLineStartingIndex += self.nFaceProfilePoints
        
        
        fid.close()
        
        

    def dump_all_data(self):
        """ Dump all data to screen (for debugging purpose)

        Returns
        -------

        """

        print("RAS2D_mesh_data class self-dump:")
        print("    hdf_filename = ", self.hdf_filename)
        print("    terrain_filename = ", self.terrain_filename)
        print("    plan_filename = ", self.plan_filename)
        print("    plan = ", self.plan)
        print("    short_identifier = ", self.short_identifier)
        print("    project_filename = ", self.project_filename)
        
        print("    comp_interval = ", self.comp_interval)
        print("    outp_interval = ", self.outp_interval)
        print("    map_interval = ", self.map_interval)
        
        print("    units = ", self.units)
        print("    short_ID = ", self.short_ID)
        
        print("    start_time = ", self.start_time)
        print("    end_time = ", self.end_time)
        print("    Dpart = ", self.Dpart)
        
        print("    solution_time = ", self.solution_time)
        print("    solution_timedates = ", self.solution_time_date)
        
        print("    2DAreaNames = ", self.TwoDAreaNames)
        print("    2DAreaCellCounts = ", self.TwoDAreaCellCounts)
        
        print("    2DAreaCellPoints = \n", self.TwoDAreaCellPoints)
        print("    2DAreaBoundaryPoints = \n", self.TwoDAreaBoundaryPoints)
        
        print("    TwoDAreaCellDepth = \n", self.TwoDAreaCellDepth)
        print("    TwoDAreaCellWSE = \n", self.TwoDAreaCellWSE)
        print("    TwoDAreapointVx = \n", self.TwoDAreaPointVx)
        print("    TwoDAreapointVy = \n", self.TwoDAreaPointVy)
        print("    TwoDAreapointVz = \n", self.TwoDAreaPointVz)
        
        


def main():
    """ Testing

    Returns
    -------

    """
    my_ras_2d_data = RAS_2D_Data("Muncie2DOnly_SI.p01.hdf","subterrain_exported.tif")
    
    #print(my_ras_2d_data.TwoDAreaFace_FacePoints[0])
    
    #my_ras_2d_data.saveHEC_RAS2D_results_to_VTK(timeStep=2)
    
    #my_ras_2d_data.exportSRHGEOMFile("Muncie2D")
    
    #my_ras_2d_data.exportSRHMATFile("Muncie2D")
    
    #my_ras_2d_data.exportBoundariesToVTK("Muncie2D_boundaries")
    
    my_ras_2d_data.exportFaceProfilesToVTK("Muncie2D_faceprofiles")
    
    #dump all data to screen (debug)
    #my_ras_2d_data.dump_all_data()
    
    print("All done!")
    
if __name__ == "__main__":
    main()
