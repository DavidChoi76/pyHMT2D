# -*- coding: utf-8 -*-
"""
Created on Sun Feb 28 09:17:08 2021

Convert HEC-RAS 2D mesh and data to SRH-2D. The generated SRHGEOM and SRHMAT files can be loaded in SMS. 
However, current version of SMS (v13.1) can only handle mesh cell shapes of triangles and quadrilaterals.
In HEC-RAS 2D, there could be polyhedrons with more than four sides. It seems SMS will discard extra
 sides and read the mesh wrong. Future versions of SMS may handle polyhydrons correctly. 

Regardless, HEC-RAS 2D meshes can still be used with SRH-2D because the model itself can handle 
polyhedrons. We simply have to prepare all the input files outside of SMS. And that is the purpose
 of this code.

The developement of this code used/modified some of the functions in HaD-to-Py (Tomkovic 2016), e.g., 
the reading of HEC-RAS's 2D result files using the HDF module. 

References:

L. A. Tomkovic (2016), HaD-to-Py, https://github.com/latomkovic/HaD-to-Py (accessed Feb. 2021)

Author: Xiaofeng Liu, PhD, PE  
Penn State University
"""

import sys
import numpy as np
import h5py
import meshio
from scipy import interpolate
from osgeo import gdal
import affine
import os.path

from ..Misc import printProgressBar

class RAS_2D_Data:
    """
    A class for HEC-RAS 2D data I/O, manipulation, and format conversion
    
    This class is designed to read HEC-RAS results in HDF format. It can 
    save RAS2D results into VTK format for visualization in Paraview, parse
    RAS2D mesh information and convert/save to SRH-2D format, query RAS2D
    results (e.g., for calibration), etc.
    
    Attributes
    ----------
    hdf_filename : str
        the name for the HDF result file generated by HEC-RAS
    plan_filename : str
        the name for the HEC-RAS run plan file
    plan : str
        the name of the HEC-RAS run plan
    short_identifier : str
        the short name of the run, called "Short Identifier" in HEC-RAS
    
    
    Methods
    -------
    get_units()    
        Get the units used in the HEC-RAS project
    
    """
    
    def __init__(self, hdf_filename, terrain_filename):
        self.hdf_filename = hdf_filename
        self.plan_filename = hdf_filename[:-4]
        self.plan = self.plan_filename[-3:]
        self.short_identifier = "Short Identifier="
        self.project_filename = self.plan_filename[:-4] + '.prj'
        self.terrain_filename = terrain_filename

        #number of points for each face's profile (subgrid terrain)
        #HEC-RAS's HDF file does not export face profile, although in RAS Mapper
        #the face profile can be plotted and tabulated. It is not clear how these face 
        #profiles are created. Here, we use a uniformed sampled terrain points on each face line.
        self.nFaceProfilePoints = 20
        
        self.comp_interval = ''
        self.outp_interval = ''
        self.map_interval = ''
        
        #get intervals
        self.get_intervals()
        
        self.units = ''
        self.short_ID = ''
        
        #get units
        self.get_units()
        
        #get short_ID
        self.get_shortID()
        
        self.start_time = ''
        self.end_time = ''
        self.Dpart = ''
        
        #get start and end times
        self.get_start_end_time()
        
        #get solution time series 
        self.solution_time = self.get2DAreaSolutionTimes()
        self.solution_time_date = self.get2DAreaSolutionTimeDates() 
        
        self.TwoDAreaNames = []
        
        #get 2D Area names
        self.get2DAreaNames()
        
        self.TwoDAreaCellCounts = []
        
        #get 2D area cell count
        self.get2DAreaCellCounts()
        
        #get 2D area cell points
        self.TwoDAreaCellPoints = self.get2DAreaCellPoints()

        #get 2D ara boundary points
        self.TwoDAreaBoundaryPoints = self.get2DAreaBoundaryPoints()
        
        #build boundaries
        self.totalBoundaries, self.boundaryTotalPoints, self.boundaryPointList = self.build2DAreaBoundaries()
        
        #get 2D area cell face points indexes
        #self.TwoDAreaCellFacePointsIndexes = self.get2DAreaCellFacePointsIndexes()
        
        #interpolator for elevation (bathymetry)
        #self.bilinterp = self.build2DInterpolatorFromGeoTiff(self.terrain_filename)
        
        #2D area face area elevation info and values
        self.TwoDAreaFaceAreaElevationInfo = []
        self.TwoDAreaFaceAreaElevationValues = []
        
        #list to store face hydraulic information: a list of lists
        self.TwoDAreaFaceHydraulicInformation = self.build2DAreaFaceHydraulicInformation()

        #list to store face points' coordinates list: a list of lists
        #e.g., TwoDAreaFacePointCoordinatesList[0] is a list of face point coordinates in 2D flow area 0
        self.TwoDAreaFacePointCoordinatesList = []

        self.build2DAreaFacePointCoordinatesList()


        #list to store cell face list: a list of lists
        #e.g., TwoDAreaCellFaceList[0][1] is a list of faces for cell 1 in 2D flow area 0
        self.TwoDAreaCellFaceList = []

        #build TwoDAreaCellFaceList
        self.build2DAreaCellFaceList()

        #land cover (Manning n)
        #This can be retrived from HDF's entries: [Geometry][Land Cover Filename] and [Geometry][Land Cover Layername]
        self.landcover_filename = ''
        self.landcover_layername = ''

        #Manning n zone dictionary: {ID: [name, Manning's n]}
        self.ManningNZones = {}
        self.build2DManningNZones()

        #cell IDs in each Manning's n zones (for srhmat output)
        self.cellsInManningZones = []

        #2D interpolator for Manning n ID from GeoTiff file
        #Note: This interpolator uses linear interpolation and returns a float (need to convert to integer ID for use)

        #get the full land cover file name (deal with relative path w.r.t. the script where RAS_2D_Data class is used)
        #fileBase = str.encode(os.path.dirname(self.hdf_filename)+'/')
        #full_landcover_filename = fileBase+self.landcover_filename

        #self.ManningNIDInterpolator = self.build2DInterpolatorFromGeoTiff(full_landcover_filename)

        #2D area Manning's n at cell center: a list for all 2D areas
        #e.g., TwoDAreaCellManningN[0][1] is the Manning's n value for cell 1 in 2D flow area 0
        self.TwoDAreaCellManningN = []

        #Set Manning's n for each cell. There are two options.
        #Option 1: interpolte Manning's n from face to cell center: TwoDAreaCellManningN
        #          This option is not accurate. Better use option 2.
        #self.interpolateManningN_face_to_cell()

        #Option 2: set Manning's n for cells from HEC-RAS's Manning's n GeoTiff and HDF files
        self.buildCellManningNFromGeoTiffHDF()

        
        #list to store face's two FacePoints
        #e.g., TwoDAreaFace_FacePoints[0][1] is a list two FacePoint IDs for face 1 in 2D flow area 0
        self.TwoDAreaFace_FacePoints = []
        
        #build TwoDAreaFace_FacePoints
        self.buildFace_FacePoints()
        
        #list to store face profile (subgrid terrain). On each face, number of points is self.nFaceProfilePoints.
        #e.g., TwoDAreaFaceProfile[0][1][0:nFaceProfilePoints,3] stores the profile for face 1 in 2D flow area 0
        self.TwoDAreaFaceProfile = []
        
        #build face profile
        #self.build2DAreaFaceProfile()
        
        #meshio object list (each 2D area corresponding to one meshio object although only one 2D area is supported)
        self.meshioObjectList = []
        
        #build the meshio object list
        self.buildMeshioObjects()
        
        #By default, HEC-RAS 2D outputs the following time series solution data in HDF file
        #   - Depth (in each cell, including the ghost cells)
        #   - Node X Vel (node velocity in x-direction)
        #   - Node Y Vel (node velocity in y-direction)
        #   - Water Surface (water surface elevation in each cell, including the ghost cells)
        #   - other solution variables at face centers (don't know how to deal with them yet)
        # load solutions for 2D areas
        self.TwoDAreaCellDepth = []
        self.TwoDAreaCellWSE = []
        self.TwoDAreaPointVx = []
        self.TwoDAreaPointVy = []
        self.TwoDAreaPointVz = []
        
        self.load2DAreaSolutions()
        

    def get_units(self):    
        """Get the units used in the HEC-RAS project
        
        Units used in HEC-RAS can be either 'Feet' or 'Meter'.
        
        """
        
        # open the HEC-RAS project file
        #print("self.project_filename = ", self.project_filename)
        with open(self.project_filename,'r') as project_file:
            lines = project_file.readlines()
            if "English Units" in lines[3]:
                self.units = 'Feet'
            elif "SI Units" in lines[3]:
                self.units = "Meter"
            else:
                self.units = "Unknown units"
 

    def get_shortID(self):
        """" Find the short_ID

        """
        with open(self.plan_filename,'r') as plan_file:
            for line in plan_file:
                if self.short_identifier in line:
                    self.shortID = line[line.index(self.short_identifier) + 
                                        len(self.short_identifier):].rpartition("\n")[0]
                    self.shortID = ' '.join(self.shortID.split())
                    break


    def get_intervals(self):
        """ Get the computation, output, and map intervals

        """
        comp_indicator = "Computation Interval="
        outp_indicator = "Output Interval="
        map_indicator = "Mapping Interval="
        
        i=0
        
        with open(self.plan_filename,'r') as plan_file:
            for line in plan_file:
                if comp_indicator in line:
                    self.comp_interval = line[line.index(comp_indicator) + 
                                              len(comp_indicator):].rpartition("\n")[0]
                    i += 1
                    if i==3:
                        break
                elif outp_indicator in line:
                    self.outp_interval = line[line.index(outp_indicator) + 
                                              len(outp_indicator):].rpartition("\n")[0]
                    i += 1
                    if i==3:
                        break
                elif map_indicator in line:
                    self.map_interval = line[line.index(map_indicator) + 
                                             len(map_indicator):].rpartition("\n")[0]
                    i += 1
                    if i==3:
                        break
         

    def get_time_minutes(self, interval):
        """ pass the interval to this function to get the minute value

        Parameters
        ----------
        interval

        Returns
        -------

        """
        interval_to_minutes = {'1MIN': 1, '2MIN':2,'3MIN':3,'4MIN':4,'5MIN':5,'10MIN':10,'15MIN':15,
                               '20MIN':20,'30MIN':30,'1HOUR':60}
        try:
            minutes = interval_to_minutes[interval]
        except:
            message = "You might need to modify the get_time_minutes() function so that there is a interval corresponding to your %s interval" %interval
            sys.exit(message)
            raise
        
        return minutes


    def get_start_end_time(self):
        """ Get the plan_filename and the start_time and end_time

        Returns
        -------

        """

        #print("plan_filename = ", self.plan_filename)
        time_indicator = "Simulation Date="
        with open(self.plan_filename,'r') as plan_file:
            for line in plan_file:
                if time_indicator in line:
                    time_line = line
                    break

        times = time_line[time_line.index(time_indicator) + len(time_indicator):]
        self.start_time = times[0:14]
        self.start_time = self.start_time.replace(","," ")
        self.end_time = times[15:]
        self.end_time = self.end_time.replace(","," ")
        self.Dpart = self.start_time[0:9]
        self.Dpart = list(self.Dpart)
        self.Dpart[0:2] = "01"
        self.Dpart = ''.join(self.Dpart)


    def get2DAreaNames(self):
        """ Get the names of 2D Flow Areas in the HEC-RAS Plan's geometry

        Returns
        -------

        """
        hf = h5py.File(self.hdf_filename,'r') 
        
        self.TwoDAreaNames = hf['Geometry']['2D Flow Areas']['Attributes']['Name']
        
        #hdf2DFlow = hf['Geometry']['2D Flow Areas']
        
        #for key in hdf2DFlow:
        #    if key in ['Attributes', 'Cell Info', 'Cell Points', 'Manning\'s n',\
        #           'Names', 'Polygon Info', 'Polygon Parts', 'Polygon Points',\
        #          'Tolerances']:
        #        continue
        #    else:
        #        self.TwoDAreaNames.append(key) # List of 2D Area names
        

    def get2DAreaCellCounts(self):
        """ Get 2D Flow Areas cell counts

        Returns
        -------

        """
        hf = h5py.File(self.hdf_filename,'r') 
        self.TwoDAreaCellCounts = hf['Geometry']['2D Flow Areas']['Attributes']['Cell Count']
        hf.close()
            

    def get2DAreaCellPoints(self):
        """ Get 2D Flow Area cell points

        Returns
        -------

        """
        hf = h5py.File(self.hdf_filename,'r') 
        hdf2DAreaCellPoints = np.array(hf['Geometry']['2D Flow Areas']['Cell Points'])
        #print(hdf2DAreaCellPoints)
        hf.close()

        return hdf2DAreaCellPoints


    def get2DAreaBoundaryPoints(self):
        """ Get 2D Flow Area boundary points (all points on boundaries)

        Returns
        -------

        """
        hf = h5py.File(self.hdf_filename,'r') 
        hdf2DAreaBoundaryPoints = np.array(hf['Geometry']['Boundary Condition Lines']['External Faces'])
        #print(hdf2DAreaBoundaryPoints)
        hf.close()

        return hdf2DAreaBoundaryPoints
    

    def build2DAreaBoundaries(self):
        """ Build boundaries with their point list

        Returns
        -------

        """
        print("Building HEC-RAS 2D area boundaries ...")
        maxNumBC = 10          #maximum number of boundaries (adjust according to the mesh)
        maxPointsPerBC = 100   #maximum number of points per boundary

        boundaryIDList = np.zeros(maxNumBC,dtype=int)   #list of boundary IDs
        boundaryPointList = np.zeros((maxNumBC,maxPointsPerBC),dtype=int)  #list of point IDs on each boundary
        boundaryTotalPoints = np.zeros(maxNumBC,dtype=int)    #total number of points in each boundary            

        #read the first row of BoundaryPoints
        totalBoundaries = 0                           #total number of boundaries
        currentBoundary = 0                           #current BC counter 
        pointCounterInCurrentBoundary = 0             #point counter in current boundary
        boundaryIDList[currentBoundary] = self.TwoDAreaBoundaryPoints[0][0]       #first BC Line ID
        boundaryPointList[currentBoundary,0] = self.TwoDAreaBoundaryPoints[0][2]  #first point
        boundaryPointList[currentBoundary,1] = self.TwoDAreaBoundaryPoints[0][3]  #second point
        pointCounterInCurrentBoundary = 2
        boundaryTotalPoints[currentBoundary] = 2
        totalBoundaries = 1

        #loop through row 2 to end of BoundaryPoints
        for k in range(self.TwoDAreaBoundaryPoints.shape[0]-1):
            if currentBoundary == self.TwoDAreaBoundaryPoints[k+1][0]: #still the old BC line
                boundaryPointList[currentBoundary,pointCounterInCurrentBoundary] = self.TwoDAreaBoundaryPoints[k+1][3] 
                pointCounterInCurrentBoundary += 1
                boundaryTotalPoints[currentBoundary] += 1
            else:                                        #a new BC line
                totalBoundaries += 1
                currentBoundary += 1
                boundaryIDList[currentBoundary] = self.TwoDAreaBoundaryPoints[k+1][0]       #BC Line ID
                boundaryPointList[currentBoundary,0] = self.TwoDAreaBoundaryPoints[k+1][2]  #first point
                boundaryPointList[currentBoundary,1] = self.TwoDAreaBoundaryPoints[k+1][3]  #second point
                pointCounterInCurrentBoundary = 2
                boundaryTotalPoints[currentBoundary] = 2
        
        #print("Total number of boundaries: ", totalBoundaries)        
        #print("boundaryTotalPoints: ", boundaryTotalPoints)
        #print("boundaryPointList: ", boundaryPointList)
    
        return totalBoundaries, boundaryTotalPoints, boundaryPointList

    def build2DManningNZones(self):
        """ Build 2D flow area's Manning n zones from the land cover (Manning's n) HDF file

        Returns
        -------

        """

        hf = h5py.File(self.hdf_filename, 'r')

        self.landcover_filename = hf['Geometry'].attrs['Land Cover Filename']
        self.landcover_layername = hf['Geometry'].attrs['Land Cover Layername']

        hf.close()

        print("Land Cover Filename = ", self.landcover_filename)
        print("Land Cover Layername = ", self.landcover_layername)

        #Some time HEC-RAS does not save land cover filename and layername to HDF because the
        #geometry association of terrain or land cover (Manning's n) is removed after the 2D area geometry
        #computation has been done.
        if len(self.landcover_filename) == 0 or len(self.landcover_layername) == 0:
            print("Land Cover Filename or Land Cover Layername in result HDF is empty. Check. Exiting ...")
            sys.exit()

        #read the Manning n zones (land cover zones)
        self.ManningNZones = {}   #clear the dictionary just in case

        fileBase = str.encode(os.path.dirname(self.hdf_filename)+'/')

        hfManningN = h5py.File(fileBase+self.landcover_layername+b'.hdf', 'r')

        dset = hfManningN['IDs']

        with dset.astype(np.uint8):
            IDs = dset[:]

        ManningN = np.array(hfManningN['ManningsN'])
        Names = hfManningN['Names']

        #print("IDs =", IDs)
        #print("ManningN =", ManningN)
        #print("Names =", Names)

        for i in range(len(IDs)):
            self.ManningNZones[IDs[i]] = [Names[i], ManningN[i]]

        print("self.ManningNZones = ", self.ManningNZones)

        hfManningN.close()


    def build2DInterpolatorFromGeoTiff(self, geoTiffFileName):
        """ Build 2D interpolator for from geoTiff file, e.g., terrain and Manning n ID, using Python interpolate.interp2d

        Assume the data is in band 1.

        This method is too slow.

        Attributes
        -------
        geoTiffFileName: name for the geoTiff file

        Returns
        -------

        """
        print('Building 2D interpolator from GeoTiff file ...')

        # Read raster
        source = gdal.Open(geoTiffFileName,gdal.GA_ReadOnly)
        #print(source)

        # Read the raster band as separate variable
        #band = source.GetRasterBand(1)

        # Print only selected metadata:
        #print ("[ NO DATA VALUE ] = ", band.GetNoDataValue()) # none
        #print ("[ MIN ] = ", band.GetMinimum())
        #print ("[ MAX ] = ", band.GetMaximum())

        nx, ny = source.RasterXSize, source.RasterYSize
        gt = source.GetGeoTransform()
        band_array = source.GetRasterBand(1).ReadAsArray().astype(np.float)

        # Compute mid-point grid spacings
        ax = np.array([gt[0] + ix*gt[1] + gt[1]/2.0 for ix in range(nx)])
        ay = np.array([gt[3] + iy*gt[5] + gt[5]/2.0 for iy in range(ny)])

        bilinterp = interpolate.interp2d(ax, ay, band_array, kind='linear')
    
        return bilinterp

    def interpolatorFromGeoTiff(self, geoTiffFileName, pointList, dataType=np.float):
        """Interpolate from a GeoTiff file given a point list.

        Parameters
        ----------
        geoTiffFileName: name of the GeoTiff file
        pointList: list of points (x,y)
        dataType: data type in the GeoTiff (default is numpy.float)

        Returns
        -------

        """
        # Read raster
        source = gdal.Open(geoTiffFileName,gdal.GA_ReadOnly)
        #print(source)

        # Read the raster band as separate variable
        data_array = np.array(source.GetRasterBand(1).ReadAsArray())

        #print(data_array.shape)

        # Print only selected metadata:
        #print ("[ NO DATA VALUE ] = ", band.GetNoDataValue()) # none
        #print ("[ MIN ] = ", band.GetMinimum())
        #print ("[ MAX ] = ", band.GetMaximum())

        forward_transform = affine.Affine.from_gdal(*source.GetGeoTransform())
        reverse_transform = ~forward_transform

        interpolatedValues = []

        #loop through all points in the list
        for pointI in range(pointList.shape[0]):
            x = pointList[pointI,0]
            y = pointList[pointI,1]

            px, py = reverse_transform * (x, y)
            px, py = int(px + 0.5), int(py + 0.5)

            #Sample with the pixel coordinates. Note that py should be first because
            # the index is [rows, columns] in a 2@ grid in python
            interpolatedValues.append(data_array[py][px])

        return interpolatedValues


    def get2DAreaCellFacePointsIndexes(self, area):
        """ Get 2D Flow Area cell face points indexes for a specified 2D area

        Parameters
        ----------
        area

        Returns
        -------

        """
        hf = h5py.File(self.hdf_filename,'r') 
        hdf2DAreaCellFacePointsIndexes = np.array(hf['Geometry']['2D Flow Areas'][area]
                                                   ['Cells FacePoint Indexes'])
        #print(hdf2DAreaCellFacePointsIndexes)
        hf.close()

        return hdf2DAreaCellFacePointsIndexes

    def get2DAreaCellCenterCoordiantes(self, area):
        """ Get 2D Flow Area cell center coordinates for a specified 2D area

        Note: these coordinates only have (x,y), no z.

        Parameters
        ----------
        area

        Returns
        -------

        """
        hf = h5py.File(self.hdf_filename, 'r')

        #in HEC-RAS v5.0.7 and earlier, the 'Cells Center Coordinate' contains also the ghost cell centers
        #Here, we only need the real centers, not the ghost.

        #Get 2D Flow Areas Attributes table
        twoDFlowAreaAttributs = hf['Geometry']['2D Flow Areas']['Attributes']

        #index of the 2D flow area in the geometry (in case there are more than one 2D flow areas)
        areaIndex = 0

        bFound = False

        for name in twoDFlowAreaAttributs['Name']:
            if name == area:
                bFound = True
                break

            areaIndex += 1

        if not bFound:
            print("The specified area with name", area, "was not found in the geometry. Exiting ...")
            sys.exit()

        #Get the start and end of current 2D flow area cell index
        temp = hf['Geometry']['2D Flow Areas']['Cell Info']
        iStart = temp[areaIndex,0]
        iEnd = temp[areaIndex,1]

        hdf2DAreaCellCenterCoordinates = np.array(hf['Geometry']['2D Flow Areas'][area]
                                                  ['Cells Center Coordinate'])[iStart:iEnd,:]
        # print(hdf2DAreaCellCenterCoordinates)
        hf.close()

        return hdf2DAreaCellCenterCoordinates


    def get2DAreaFacePointsCoordinates(self, area):
        """ Get the face points' coordinates for a specified 2D area

        Parameters
        ----------
        area

        Returns
        -------

        """
        hf = h5py.File(self.hdf_filename,'r') 
        hdf2DAreaFacePointsCoordinates = np.array(hf['Geometry']['2D Flow Areas'][area]['FacePoints Coordinate'])
        
        #print(hdf2DAreaFacePointsCoordinates)
        
        #add the third column to the coordinates array for the z-coordinates (RAS2D only exports x and y, not z)
        z_temp = np.zeros(hdf2DAreaFacePointsCoordinates.shape[0])
        
        hdf2DAreaFacePointsCoordinates3D = np.column_stack((hdf2DAreaFacePointsCoordinates, z_temp))
        
        #interpolate the elevation (bathymetry) to z coordinates
        self.interpolateZcoord2Points(hdf2DAreaFacePointsCoordinates3D)
        
        #print(hdf2DAreaFacePointsCoordinates3D)

        hf.close()
        
        return hdf2DAreaFacePointsCoordinates3D
    

    def interpolateZcoord2Points(self, facePointsCoordinates3D):
        """ Interpolate the elevation (bathymetry) to 2D area's points (z-coordinate)

        Parameters
        ----------
        facePointsCoordinates3D

        Returns
        -------

        """

        allFacePointsCoordiantes=np.empty([facePointsCoordinates3D.shape[0],2])

        for k in range(facePointsCoordinates3D.shape[0]):
            x1 = facePointsCoordinates3D[k,0]
            y1 = facePointsCoordinates3D[k,1]

            allFacePointsCoordiantes[k,0] = x1
            allFacePointsCoordiantes[k,1] = y1

        allFacePointZ = self.interpolatorFromGeoTiff(self.terrain_filename, allFacePointsCoordiantes)
        
        for k in range(facePointsCoordinates3D.shape[0]):
            facePointsCoordinates3D[k,2] = allFacePointZ[k]


    def get2DAreaCellsFaceOrientationInfo(self, area):
        """ Get cells face and orientation info for a specified 2D area

        Parameters
        ----------
        area

        Returns
        -------

        """
        hf = h5py.File(self.hdf_filename,'r') 
        hdf2DAreaCellsFaceOrientationInfo = np.array(hf['Geometry']['2D Flow Areas'][area]['Cells Face and Orientation Info'])
        #print(hdf2DAreaCellsFaceOrientationInfo)

        hf.close()

        return hdf2DAreaCellsFaceOrientationInfo


    def get2DAreaCellsFaceOrientationValues(self, area):
        """ Get cells face and orientation values for a specified 2D area

        Parameters
        ----------
        area

        Returns
        -------

        """
        hf = h5py.File(self.hdf_filename,'r') 
        hdf2DAreaCellsFaceOrientationValues = np.array(hf['Geometry']['2D Flow Areas'][area]['Cells Face and Orientation Values'])
        #print(hdf2DAreaCellsFaceOrientationValues)

        hf.close()

        return hdf2DAreaCellsFaceOrientationValues    
    

    def get2DAreaFaceAreaElevationInfo(self, area):
        """ Get faces area elevation info for a specified 2D area

        Two columns: first column-starting index, second column-length of record

        Parameters
        ----------
        area

        Returns
        -------

        """
        hf = h5py.File(self.hdf_filename,'r') 
        hdf2DAreaFaceAreaElevationInfo = np.array(hf['Geometry']['2D Flow Areas'][area]['Faces Area Elevation Info'])
        #print(hdf2DAreaFaceAreaElevationInfo)

        hf.close()

        return hdf2DAreaFaceAreaElevationInfo    
    

    def get2DAreaFaceAreaElevationValues(self, area):
        """ Get faces area elevation values for a specified 2D area

        Four columns: first column-elevation, second column-area
                     third column-wetted perimeter, fourth column-Manning's n (a constant as of now RAS version <=6)

        Parameters
        ----------
        area

        Returns
        -------

        """
        hf = h5py.File(self.hdf_filename,'r') 
        hdf2DAreaFaceAreaElevationValues = np.array(hf['Geometry']['2D Flow Areas'][area]['Faces Area Elevation Values'])
        #print(hdf2DAreaFaceAreaElevationValues)

        hf.close()

        return hdf2DAreaFaceAreaElevationValues 
    

    def get2DAreaFaceFacePointIndexes(self, area):
        """ Get face's facepoint indexes (two interger IDs)

        Parameters
        ----------
        area

        Returns
        -------

        """

        hf = h5py.File(self.hdf_filename,'r') 
        hdf2DAreaFaceFacePointIndexes = np.array(hf['Geometry']['2D Flow Areas'][area]['Faces FacePoint Indexes'])
        #print(hdf2DAreaFaceFacePointIndexes)

        hf.close()

        return hdf2DAreaFaceFacePointIndexes  
    

    def hdf2DAreaResultVar(self, area, varName):
        """ Get HEC-RAS solution time series result for a given variable

        Parameters
        ----------
        area
        varName

        Returns
        -------

        """
        hf = h5py.File(self.hdf_filename,'r') 
        hdf2DAreaResultVar = np.array(hf['Results']['Unsteady']['Output']['Output Blocks']
                  ['Base Output']['Unsteady Time Series']['2D Flow Areas'][area][varName])
        
        #only take the last row (time step)
        #hdf2DAreaResultVar = hdf2DAreaResultVar[(hdf2DAreaResultVar.shape[0]-1)]
        #print(varName, hdf2DAreaResultVar)

        hf.close()

        return hdf2DAreaResultVar
    

    def get2DAreaSolutionTimes(self):
        """ Get 2D Flow Area solution times

        Returns
        -------

        """
        hf = h5py.File(self.hdf_filename,'r') 
        hdf2DAreaSolutionTimes = np.array(hf['Results']['Unsteady']['Output']['Output Blocks']
                  ['Base Output']['Unsteady Time Series']['Time'])
        #print(hdf2DAreaSolutionTimes)

        hf.close()

        return hdf2DAreaSolutionTimes
    

    def get2DAreaSolutionTimeDates(self):
        """ Get 2D Flow Area solution time_dates

        Returns
        -------

        """
        hf = h5py.File(self.hdf_filename,'r') 
        hdf2DAreaSolutionTimeDates = np.array(hf['Results']['Unsteady']['Output']['Output Blocks']
                  ['Base Output']['Unsteady Time Series']['Time Date Stamp'])
        #print(hdf2DAreaSolutionTimeDates)

        hf.close()

        return hdf2DAreaSolutionTimeDates


    def load2DAreaSolutions(self):
        """ # Load solutions (cell depth and water surface elevation, node X and Y vel.) for all 2D areas

        Returns
        -------

        """
        print('Loading 2D area solutions ...')
        #loop through each 2D areas
        for area,i in zip(self.TwoDAreaNames, range(len(self.TwoDAreaNames))):
            #print("2D Flow Area = ", area)
            
            #fetch the depth and WSE data
            cellDepth = self.hdf2DAreaResultVar(area, 'Depth')
            cellWSE = self.hdf2DAreaResultVar(area, 'Water Surface')
            
            #slice the cell data array to get values only for cells in current 2D area. 
            #The HEC-RAS results also contain values at the center of boundary faces.
            cellDepth = cellDepth[0:(self.TwoDAreaCellCounts[i])]
            cellWSE = cellWSE[0:(self.TwoDAreaCellCounts[i])]

            self.TwoDAreaCellDepth.append(cellDepth)
            self.TwoDAreaCellWSE.append(cellWSE)
            
            #fetch point data
            #Node X Vel and Node Y Vel
            pointVx=self.hdf2DAreaResultVar(area, 'Node X Vel')
            pointVy=self.hdf2DAreaResultVar(area, 'Node Y Vel')
            
            self.TwoDAreaPointVx.append(pointVx)
            self.TwoDAreaPointVy.append(pointVy)
            self.TwoDAreaPointVz.append(pointVx*0.0) #fake z velocity (=0)


    def assembleVectors(self, pointVx, pointVy, pointVz):
        """ Assemble vectors from their components and return the array

        Parameters
        ----------
        pointVx
        pointVy
        pointVz

        Returns
        -------

        """
   
        assert(len(pointVx)==len(pointVy))
    
        V = np.zeros((len(pointVx),3))
    
        for i in np.arange(len(pointVx)):
            #print(i,V[i,0],pointVx[i])
            V[i,0] = pointVx[i]
            V[i,1] = pointVy[i]
            V[i,2] = pointVz[i]
    
        return V

    def build2DAreaFaceHydraulicInformation(self):
        """ For 2D flow area, build face hydraulic information table (face area elevation)

        Returns
        -------

        """
        print("Building 2D area's face hydraulic information ...")

        areaFaceHydraulicInformationTable = []

        #loop through each 2D areas
        for area,i in zip(self.TwoDAreaNames, range(len(self.TwoDAreaNames))):
            #print("2D Flow Area = ", area)
            
            #get face area elevation info
            faceAreaElevationInfo = self.get2DAreaFaceAreaElevationInfo(area)
            
            self.TwoDAreaFaceAreaElevationInfo.append(faceAreaElevationInfo)
            
            #get face area elevation values
            faceAreaElevationValues = self.get2DAreaFaceAreaElevationValues(area)
            
            self.TwoDAreaFaceAreaElevationValues.append(faceAreaElevationValues)
            
            #print("Total number of faces in this area: ", faceAreaElevationInfo.shape[0])
            
            #temp list to store the numpy arrays (tables) for each face in current area
            currAreaFaceHydraulicInformationTable = []
            
            #loop through all faces in this area
            for faceI in range(faceAreaElevationInfo.shape[0]):
                #print("faceI = ", faceI)
                
                faceData = np.zeros([faceAreaElevationInfo[faceI,1],4]) #the four columns: elevation, area, wetted perimeter, and Manning's n
                
                start_row = faceAreaElevationInfo[faceI,0]
                end_row = faceAreaElevationInfo[faceI,0] + faceAreaElevationInfo[faceI,1]
                
                faceData = faceAreaElevationValues[start_row:end_row,:].copy() #make a copy
                #print("faceData = ", faceData)
                
                currAreaFaceHydraulicInformationTable.append(faceData)                
            
            #append the current area's faceHydraulicInformation table to the top list
            areaFaceHydraulicInformationTable.append(currAreaFaceHydraulicInformationTable)
            
            return areaFaceHydraulicInformationTable
                
            
    def build2DAreaFacePointCoordinatesList(self):
        """ Build face point coordinates list

        Returns
        -------

        """

        print("Building 2D area's face point coordinates list ...")

        #loop through each 2D areas
        for area,i in zip(self.TwoDAreaNames, range(len(self.TwoDAreaNames))):
            #print("2D Flow Area = ", area)

            #get the FacePoint coordinates in the current 2D flow area
            facePointsCoordinates = self.get2DAreaFacePointsCoordinates(area)

            self.TwoDAreaFacePointCoordinatesList.append(facePointsCoordinates)


    def build2DAreaCellFaceList(self):
        """ Build cell's face list

        Returns
        -------

        """
        print("Building 2D area's cell face list ...")

        #loop through each 2D areas
        for area,i in zip(self.TwoDAreaNames, range(len(self.TwoDAreaNames))):
            #print("2D Flow Area = ", area)

            #get cells face and orientation info
            cellsFaceOrientationInfo = self.get2DAreaCellsFaceOrientationInfo(area)
                
            #get cells face and orientation values
            cellsFaceOrientationValues = self.get2DAreaCellsFaceOrientationValues(area)
            
            #temp list to store the numpy arrays (face list) for each cell in current area
            currAreaCellFaceList = []
            
            #loop through cells in current area
            for cellI in range(self.TwoDAreaCellCounts[i]):
                start_row = cellsFaceOrientationInfo[cellI,0]
                end_row = cellsFaceOrientationInfo[cellI,0] + cellsFaceOrientationInfo[cellI,1]
                
                faceList = cellsFaceOrientationValues[start_row:end_row,0].copy() #make a copy
                #print("faceList =", faceList)
                
                currAreaCellFaceList.append(faceList)
                
            #append the current area's cell face list to the top list
            self.TwoDAreaCellFaceList.append(currAreaCellFaceList)


    def horizontalDistance(self, point1, point2):
        """ Horizontal distance between two points

        Parameters
        ----------
        point1
        point2

        Returns
        -------

        """
        return np.sqrt(np.square(point2[0] - point1[0]) + np.square(point2[1] - point1[1]))
                

    def build2DAreaFaceProfile(self):
        """ Build face profile

        Returns
        -------

        """
        print("Building 2D area's face profile ...")

        #loop through each 2D areas
        for area,i in zip(self.TwoDAreaNames, range(len(self.TwoDAreaNames))):
            #print("2D Flow Area = ", area)
            
            face_facePoints = self.TwoDAreaFace_FacePoints[i]
            
            #get the FacePoint coordinates in the current 2D flow area
            facePointsCoordinates = self.get2DAreaFacePointsCoordinates(area)
            
            curAreaProfilePoints = []

            #loop through all faces in current area (it is a slow process; print a progress bar)
            for faceI in range(face_facePoints.shape[0]):

                printProgressBar(faceI, face_facePoints.shape[0], "Face profile computation in progress")

                #print("faceI =", faceI)
                facePoint_start = face_facePoints[faceI,0]  #start ID of facePoint
                facePoint_end = face_facePoints[faceI,1]    #end ID of facePoint
                
                #get the coordinates of the start and end facePoints
                startFacePointCoordinates = facePointsCoordinates[facePoint_start]
                endFacePointCoordinates = facePointsCoordinates[facePoint_end]
                
                length = self.horizontalDistance(startFacePointCoordinates,endFacePointCoordinates)
                
                stations = np.linspace(0,length,self.nFaceProfilePoints,endpoint=True)
                
                #if faceI == 0: print(repr(stations))
                
                #print(startFacePointCoordinates)
                #print(endFacePointCoordinates)
                
                #create the array for the coordinates of all points on the profile 
                #(x,y,z)
                profilePoints = np.zeros((self.nFaceProfilePoints,3))
                
                for pointI in range(self.nFaceProfilePoints):
                    profilePoints[pointI,:] = (startFacePointCoordinates + (endFacePointCoordinates-startFacePointCoordinates)
                                           *pointI/(self.nFaceProfilePoints-1))
                    
                #if faceI == 0: print(repr(profilePoints))
                    
                self.interpolateZcoord2Points(profilePoints)
                
                #if faceI == 0: print(repr(profilePoints))    
                
                curAreaProfilePoints.append(profilePoints)
                
                
            self.TwoDAreaFaceProfile.append(curAreaProfilePoints)
            

    def interpolateManningN_face_to_cell(self):
        """ interpolate Manning's n from face to cell center
        HEC-RAS 2D stores Manning's n value at faces, not cell centers. We need to
        interpolate its value from face to cell center. Another option is to use the
        cell center coordinates and direclty query the Manning's n layer in RAS Mapper, which
        might be too complicated because HEC-RAS has default Manning's n, Land Use Cover, Override polygon, etc.
        Here, the interpolation from face to cell might not be a bad choice.

        For each face, HEC-RAS currently does not support varying Manning's n (horizontally and veritcally). Thus,
        effectively, it is a constant value for each face. This may change in the future.

        Returns
        -------

        """
        print("Interpolating Manning's n from face to cell center ...")

        #clear the list up in case this function has been called before
        self.TwoDAreaCellManningN = []
        
        #loop through each 2D areas
        for area,i in zip(self.TwoDAreaNames, range(len(self.TwoDAreaNames))):
            #print("2D Flow Area = ", area)
            
            temp_n = np.zeros(self.TwoDAreaCellCounts[i])
            
            #loop through cells in current area
            for cellI in range(self.TwoDAreaCellCounts[i]):
                sum_n = 0.0
                #loop through all faces of current cell
                for faceI in self.TwoDAreaCellFaceList[i][cellI]:
                    sum_n += self.TwoDAreaFaceHydraulicInformation[i][faceI][0,3] #only take the first value because
                                                                                  #it is constant for each face

                temp_n[cellI] = sum_n/len(self.TwoDAreaCellFaceList[i][cellI])

            self.TwoDAreaCellManningN.append(temp_n)


    def buildCellManningNFromGeoTiffHDF(self):
        """ Build 2D flow area cell's Manning n value from HEC-RAS's GeoTiff and HDF files for Manning n.

        This method is more accurate than interpolateManningN_face_to_cell(), which uses a face to cell interpolation.



        Returns
        -------

        """
        print("Building cell's Manning n values from GeoTiff and HDF ...")

        self.TwoDAreaCellManningN = []
        self.TwoDAreaCellManningN.append(np.zeros(self.TwoDAreaCellCounts[0]))

        cell_center_coordinates = np.array(self.get2DAreaCellCenterCoordiantes(self.TwoDAreaNames[0]))

        #loop through each cell
        #for cellI in range(self.TwoDAreaCellCounts[0]):
        #    ManningN_ID = int(self.ManningNIDInterpolator(cell_center_coordinates[cellI,0],
        #                                                  cell_center_coordinates[cellI,1]))
        #    cell_ManningN[cellI] = self.ManningNZones[ManningN_ID][1]  #get the Manning n value

        #get the full land cover file name (deal with relative path w.r.t. the script where RAS_2D_Data class is used)
        fileBase = str.encode(os.path.dirname(self.hdf_filename)+'/')
        full_landcover_filename = fileBase+self.landcover_filename

        ManningN_IDs = self.interpolatorFromGeoTiff(full_landcover_filename, cell_center_coordinates)

        #set the Manning's n values for each cells
        for cellI in range(self.TwoDAreaCellCounts[0]):
            self.TwoDAreaCellManningN[0][cellI] = self.ManningNZones[ManningN_IDs[cellI]][1]  #get the Manning n value

        #bin each cell to different Manning's n zones
        self.cellsInManningZones = [ [] for _ in range(len(self.ManningNZones))]  # a list of lists

        for cellI in range(self.TwoDAreaCellCounts[0]):
            if self.cellsInManningZones[ManningN_IDs[cellI]]:
                self.cellsInManningZones[ManningN_IDs[cellI]].append(cellI)
            else:
                self.cellsInManningZones[ManningN_IDs[cellI]] = [cellI]

        print("cellsInManningZones = ", self.cellsInManningZones)

    #build face's facepoint list
    def buildFace_FacePoints(self):
        print("Building face's facepoints list ...")
        
        #loop through each 2D areas
        for area,i in zip(self.TwoDAreaNames, range(len(self.TwoDAreaNames))):
            #print("2D Flow Area = ", area)

            #get cells face and orientation info
            faceFacePointIndexes = self.get2DAreaFaceFacePointIndexes(area)
            
            self.TwoDAreaFace_FacePoints.append(faceFacePointIndexes)
                    
            

    def saveHEC_RAS2D_results_to_VTK(self,timeStep=-1,lastTimeStep=False,dir=''):
        """ Save HEC-RAS 2D solutions to VTK files.

        Note:
           - Each area saved separately
           - Each time saved separately
        The resulted files will be RAS2D_areaName_timeSequence.vtk, e.g.,
        RAS2D_SpringCreek_0001.vtk, RAS2D_SpringCreek_0002.vtk, etc.

        The option lastTimeStep specifies whether only the last time step is saved (default=False).
        The option timeStep specifies the particular step to be saved.
        If both lastTimeSTep and timeStep are specified, lastTimeStep has the priority.

        Parameters
        ----------
        timeStep: {int} -- only the specified time step will be saved
        lastTimeStep: {bool} -- optionally specify only the last time step
        dir: {string} -- optional directory name

        Returns
        -------

        """
        print('Saving RAS2D results to VTK ...')
        
        #check the sanity of timeStep
        if (timeStep != -1) and (not timeStep in range(len(self.solution_time))):
            message = "Specified timeStep = %d not in range (0 to %d)." % (timeStep, len(self.solution_time))
            sys.exit(message)

        #get units for variable name appendix (like SRH-2D)
        varLengthNameAppendix = ''
        varVelocityNameAppendix = ''
        print("HEC-RAS project units =",self.units)
        if self.units == 'Feet':
            varLengthNameAppendix = '_ft'
            varVelocityNameAppendix = '_ft_p_s'
        elif self.units == 'Meter':
            varLengthNameAppendix = '_m'
            varVelocityNameAppendix = '_m_p_s'
        else:
            print("Wrong units specified in the HEC-RAS project file. Exiting ...")
            sys.exit()
        
        #loop through each 2D areas
        for area,i in zip(self.TwoDAreaNames, range(len(self.TwoDAreaNames))):
            #print("2D Flow Area = ", area)
            
            #get the FacePoint indexes
            cellFacePointIndexes = self.get2DAreaCellFacePointsIndexes(area)
    
            #get the FacePoint coordinates
            facePointsCoordinates = self.get2DAreaFacePointsCoordinates(area)
    
            #get cells face and orientation info
            cellsFaceOrientationInfo = self.get2DAreaCellsFaceOrientationInfo(area)
            
            #get current 2D area's solutions
            cellDepth = self.TwoDAreaCellDepth[i]
            cellWSE = self.TwoDAreaCellWSE[i]
            pointVx = self.TwoDAreaPointVx[i]
            pointVy = self.TwoDAreaPointVy[i]
            pointVz = self.TwoDAreaPointVz[i]
            
            #add Manning's n value for visualization
            cellManningN = self.TwoDAreaCellManningN[i]
            
            #print("self.TwoDAreaCellDepth = ", self.TwoDAreaCellDepth)
            #print("type(cellDepth) =", type(cellDepth))
            #print("cellDepth =", cellDepth)
            
            #loop through solution times 
            for timeI in range(len(self.solution_time)):
                
                if lastTimeStep:
                    if timeI < (len(self.solution_time)-1):
                        continue
                    
                if (timeStep != -1) and (timeI != timeStep):
                    continue
                
                print("timeI = ", timeI)
                
                #loop through each cell in the current 2D area
                #lists to store the point indexes of cells of different shapes
                tri_pointIndexes_list = []
                quad_pointIndexes_list = []
                polygon5_pointIndexes_list = []
                polygon6_pointIndexes_list = []
                polygon7_pointIndexes_list = []
                polygon8_pointIndexes_list = []    
    
                #lists to store the cell center results
                tri_cellDepth_list = []
                quad_cellDepth_list = []
                polygon5_cellDepth_list = []
                polygon6_cellDepth_list = []
                polygon7_cellDepth_list = []
                polygon8_cellDepth_list = []    
    
                tri_cellWSE_list = []
                quad_cellWSE_list = []
                polygon5_cellWSE_list = []
                polygon6_cellWSE_list = []
                polygon7_cellWSE_list = []
                polygon8_cellWSE_list = []
                
                tri_ManningN_list = []
                quad_ManningN_list = []
                polygon5_ManningN_list = []
                polygon6_ManningN_list = []
                polygon7_ManningN_list = []
                polygon8_ManningN_list = []
    
                for celli in range(self.TwoDAreaCellCounts[i]):
                    #get the number of face points (=number of faces)
                    numFP = cellsFaceOrientationInfo[celli,1]
                    #print("numFP = ", numFP)
        
                    if numFP==3:  #triangle, only has 3 points
                        #print("trinalge")
                        tri_pointIndexes_list.append(cellFacePointIndexes[celli][0:3])
                        tri_cellDepth_list.append(cellDepth[timeI,:][celli])
                        tri_cellWSE_list.append(cellWSE[timeI,:][celli])
                        tri_ManningN_list.append(cellManningN[celli])
                    elif numFP == 4:  #quad
                        #print("quad")
                        quad_pointIndexes_list.append(cellFacePointIndexes[celli][0:4])
                        #print("cellDepth[timeI,:] = ", cellDepth[timeI,:])
                        #print("cellDepth[timeI,:][celli] = ", cellDepth[timeI,:][celli])
                        quad_cellDepth_list.append(cellDepth[timeI,:][celli])
                        quad_cellWSE_list.append(cellWSE[timeI,:][celli])
                        quad_ManningN_list.append(cellManningN[celli])
                    elif numFP == 5:  #polygon5
                        #print("polygon5")
                        polygon5_pointIndexes_list.append(cellFacePointIndexes[celli][0:5])
                        polygon5_cellDepth_list.append(cellDepth[timeI,:][celli])
                        polygon5_cellWSE_list.append(cellWSE[timeI,:][celli])
                        polygon5_ManningN_list.append(cellManningN[celli])
                    elif numFP == 6:  #polygon6
                        #print("polygon6")
                        polygon6_pointIndexes_list.append(cellFacePointIndexes[celli][0:6])
                        polygon6_cellDepth_list.append(cellDepth[timeI,:][celli])
                        polygon6_cellWSE_list.append(cellWSE[timeI,:][celli])
                        polygon6_ManningN_list.append(cellManningN[celli])
                    elif numFP == 7:  #polygon7
                        #print("polygon7")
                        polygon7_pointIndexes_list.append(cellFacePointIndexes[celli][0:7])
                        polygon7_cellDepth_list.append(cellDepth[timeI,:][celli])
                        polygon7_cellWSE_list.append(cellWSE[timeI,:][celli])
                        polygon7_ManningN_list.append(cellManningN[celli])
                    elif numFP == 8:  #polygon8
                        #print("polygon8")
                        polygon8_pointIndexes_list.append(cellFacePointIndexes[celli][0:8])
                        polygon8_cellDepth_list.append(cellDepth[timeI,:][celli])
                        polygon8_cellWSE_list.append(cellWSE[timeI,:][celli])   
                        polygon8_ManningN_list.append(cellManningN[celli])
                    else:
                        print("The cell shape is not supported")
            
                #convert the list to numpy array
                tri_pointIndexes = np.array(tri_pointIndexes_list)
                quad_pointIndexes = np.array(quad_pointIndexes_list)
                polygon5_pointIndexes = np.array(polygon5_pointIndexes_list)
                polygon6_pointIndexes = np.array(polygon6_pointIndexes_list)   
                polygon7_pointIndexes = np.array(polygon7_pointIndexes_list)
                polygon8_pointIndexes = np.array(polygon8_pointIndexes_list)
    
                tri_cellDepth = np.array(tri_cellDepth_list)
                quad_cellDepth = np.array(quad_cellDepth_list)
                polygon5_cellDepth = np.array(polygon5_cellDepth_list)
                polygon6_cellDepth = np.array(polygon6_cellDepth_list)
                polygon7_cellDepth = np.array(polygon7_cellDepth_list)
                polygon8_cellDepth = np.array(polygon8_cellDepth_list)
    
                tri_cellWSE = np.array(tri_cellWSE_list)
                quad_cellWSE = np.array(quad_cellWSE_list)
                polygon5_cellWSE = np.array(polygon5_cellWSE_list)
                polygon6_cellWSE = np.array(polygon6_cellWSE_list)
                polygon7_cellWSE = np.array(polygon7_cellWSE_list)
                polygon8_cellWSE = np.array(polygon8_cellWSE_list)
    
                tri_cellElev = tri_cellWSE - tri_cellDepth
                quad_cellElev = quad_cellWSE - quad_cellDepth
                polygon5_cellElev = polygon5_cellWSE - polygon5_cellDepth
                polygon6_cellElev = polygon6_cellWSE - polygon6_cellDepth
                polygon7_cellElev = polygon7_cellWSE - polygon7_cellDepth
                polygon8_cellElev = polygon8_cellWSE - polygon8_cellDepth
                
                tri_ManningN = np.array(tri_ManningN_list)
                quad_ManningN = np.array(quad_ManningN_list)
                polygon5_ManningN = np.array(polygon5_ManningN_list)
                polygon6_ManningN = np.array(polygon6_ManningN_list)
                polygon7_ManningN = np.array(polygon7_ManningN_list)
                polygon8_ManningN = np.array(polygon8_ManningN_list)                
                
                #print("quad_pointIndexes = ", quad_pointIndexes)
                #print('len(quad_pointIndexes) = ',len(quad_pointIndexes))
                
                #define the cells dictionary
                cellsDict = dict()
                if len(tri_pointIndexes)!=0:
                    cellsDict.update({'triangle' : tri_pointIndexes})   
        
                if len(quad_pointIndexes)!=0:
                    cellsDict.update({'quad' : quad_pointIndexes})    
        
                if len(polygon5_pointIndexes)!=0:
                    cellsDict.update({'polygon5' : polygon5_pointIndexes})       
        
                if len(polygon6_pointIndexes)!=0:
                    cellsDict.update({'polygon6' : polygon6_pointIndexes})  
        
                if len(polygon7_pointIndexes)!=0:
                    cellsDict.update({'polygon7' : polygon7_pointIndexes})    
        
                if len(polygon8_pointIndexes)!=0:
                    cellsDict.update({'polygon8' : polygon8_pointIndexes})   

                #print(cellsDict)
        
                #create the mesh without any data
                hec_ras_mesh = meshio.Mesh(facePointsCoordinates,cellsDict)
                
                #add data to the meshio mesh
    
                #add cell center scalar data
                #cellDataDict = {}
    
                #cell water depth
                #concatenate cell depth numpy arrays into one
                all_cellDepth = np.concatenate([tri_cellDepth, quad_cellDepth, polygon5_cellDepth, 
                                                polygon6_cellDepth, polygon7_cellDepth, polygon8_cellDepth])
                cellDataDict = {'Water_Depth'+varLengthNameAppendix: all_cellDepth}
    
                #print(cellDataDict)
                #print("all_cellDepth =", all_cellDepth)
    
                #cell WSE
                all_cellWSE = np.concatenate([tri_cellWSE, quad_cellWSE, polygon5_cellWSE, 
                                              polygon6_cellWSE, polygon7_cellWSE, polygon8_cellWSE])
                cellDataDict['Water_Elev'+varLengthNameAppendix] = all_cellWSE
    
                #cell center elevation
                all_cellElev = np.concatenate([tri_cellElev, quad_cellElev, polygon5_cellElev, 
                                               polygon6_cellElev, polygon7_cellElev, polygon8_cellElev])
                cellDataDict['Bed_Elev'+varLengthNameAppendix] = all_cellElev
                    
                hec_ras_mesh.cell_data = cellDataDict
                
                #cell center Manning's n
                all_cellManningN = np.concatenate([tri_ManningN, quad_ManningN, polygon5_ManningN, 
                                                polygon6_ManningN, polygon7_ManningN, polygon8_ManningN])
                cellDataDict['ManningN'] = all_cellManningN
                
                #print(hec_ras_mesh.cell_data)
                
                # add point data
                
                pVel3D = self.assembleVectors(pointVx[timeI,:], pointVy[timeI,:], pointVz[timeI,:])
                #print(pVel3D)
    
                print("Add velocity to pointDataDict.")
                pointDataDict = {'Velocity'+varVelocityNameAppendix: pVel3D}
                
                hec_ras_mesh.point_data = pointDataDict
    
                #add field data: 
                #    - Time (float)
                #    - Time_Date (string)
                #field_data = {'TIME': np.array([self.solution_time[timeI]]), 'DATE_TIME': str(self.solution_time_date[timeI],'utf-8')}
                field_data = {'TIME': np.array([self.solution_time[timeI]])}
                
                hec_ras_mesh.field_data = field_data
                
                #write to vtk file
                fileName_temp = []
                if dir!= '':
                    fileName_temp = [dir, '/', 'RAS2D_', area.astype(str), '_', str(timeI).zfill(4),'.vtk']
                else:
                    fileName_temp = ['RAS2D_', area.astype(str), '_', str(timeI).zfill(4), '.vtk']
                vtkFileName = "".join(fileName_temp)
                meshio.write(vtkFileName,hec_ras_mesh,"vtk",binary=False)


    def buildMeshioObjects(self):
        """ Build meshio objects for each 2D areas in the RAS2D mesh (although for now only one 2D area is supported)

        Returns
        -------

        """
        print("Building meshio objects ...")
        #loop through each 2D areas
        for area,i in zip(self.TwoDAreaNames, range(len(self.TwoDAreaNames))):
            #print("2D Flow Area = ", area)
            
            #get the FacePoint indexes
            cellFacePointIndexes = self.get2DAreaCellFacePointsIndexes(area)
    
            #get the FacePoint coordinates
            facePointsCoordinates = self.get2DAreaFacePointsCoordinates(area)
    
            #get cells face and orientation info
            cellsFaceOrientationInfo = self.get2DAreaCellsFaceOrientationInfo(area)
            
                
            #loop through each cell in the current 2D area
            #lists to store the point indexes of cells of different shapes
            tri_pointIndexes_list = []
            quad_pointIndexes_list = []
            polygon5_pointIndexes_list = []
            polygon6_pointIndexes_list = []
            polygon7_pointIndexes_list = []
            polygon8_pointIndexes_list = []    
    
            for celli in range(self.TwoDAreaCellCounts[i]):
                #get the number of face points (=number of faces)
                numFP = cellsFaceOrientationInfo[celli,1]
                #print("numFP = ", numFP)
        
                if numFP==3:  #triangle, only has 3 points
                    #print("trinalge")
                    tri_pointIndexes_list.append(cellFacePointIndexes[celli][0:3])
                elif numFP == 4:  #quad
                    #print("quad")
                    quad_pointIndexes_list.append(cellFacePointIndexes[celli][0:4])
                elif numFP == 5:  #polygon5
                    #print("polygon5")
                    polygon5_pointIndexes_list.append(cellFacePointIndexes[celli][0:5])
                elif numFP == 6:  #polygon6
                    #print("polygon6")
                    polygon6_pointIndexes_list.append(cellFacePointIndexes[celli][0:6])
                elif numFP == 7:  #polygon7
                    #print("polygon6")
                    polygon7_pointIndexes_list.append(cellFacePointIndexes[celli][0:7])
                elif numFP == 8:  #polygon8
                    #print("polygon6")
                    polygon8_pointIndexes_list.append(cellFacePointIndexes[celli][0:8])
                else:
                    print("The cell shape is not supported")
            
            #convert the list to numpy array
            tri_pointIndexes = np.array(tri_pointIndexes_list)
            quad_pointIndexes = np.array(quad_pointIndexes_list)
            polygon5_pointIndexes = np.array(polygon5_pointIndexes_list)
            polygon6_pointIndexes = np.array(polygon6_pointIndexes_list)   
            polygon7_pointIndexes = np.array(polygon7_pointIndexes_list)
            polygon8_pointIndexes = np.array(polygon8_pointIndexes_list)
                
            #print("quad_pointIndexes = ", quad_pointIndexes)
            #print('len(quad_pointIndexes) = ',len(quad_pointIndexes))
                
            #define the cells dictionary
            cellsDict = dict()
            if len(tri_pointIndexes)!=0:
                cellsDict.update({'triangle' : tri_pointIndexes})   
        
            if len(quad_pointIndexes)!=0:
                cellsDict.update({'quad' : quad_pointIndexes})    
        
            if len(polygon5_pointIndexes)!=0:
                cellsDict.update({'polygon5' : polygon5_pointIndexes})       
        
            if len(polygon6_pointIndexes)!=0:
                cellsDict.update({'polygon6' : polygon6_pointIndexes})  
        
            if len(polygon7_pointIndexes)!=0:
                cellsDict.update({'polygon7' : polygon7_pointIndexes})    
        
            if len(polygon8_pointIndexes)!=0:
                cellsDict.update({'polygon8' : polygon8_pointIndexes})   

            #print(cellsDict)
        
            #create the mesh without any data
            hec_ras_mesh = meshio.Mesh(facePointsCoordinates,cellsDict)
            
            self.meshioObjectList.append(hec_ras_mesh)
                
            #write to vtk file (for debug)
            #fileName_temp = ['RAS2D_meshonly_', area.astype(str),'_Area', str(i).zfill(4),'.vtk']
            #vtkFileName = "".join(fileName_temp)
            #meshio.write(vtkFileName,hec_ras_mesh,"vtk",binary=False)


    def exportSRHGEOMFile(self, srhgeomFileName):
        """ Export srhgeom file

        Parameters
        ----------
        srhgeomFileName

        Returns
        -------

        """
        #only the first 2D area is exported. 

        # get the cell's FacePoint indexes
        cellFacePointIndexes = self.get2DAreaCellFacePointsIndexes(self.TwoDAreaNames[0])

        # get the FacePoint coordinates
        facePointsCoordinates = self.TwoDAreaFacePointCoordinatesList[0]

        # get cells face and orientation info
        cellsFaceOrientationInfo = self.get2DAreaCellsFaceOrientationInfo(self.TwoDAreaNames[0])
        
        #write out to srhgeom file
        fname = srhgeomFileName + '.srhgeom'
        print("Writing SRHGEOM file: ", fname)
    
        try:
            fid = open(fname, 'w')
        except IOError:
            print('.srhgeom error')
            sys.exit()
    
        fid.write('SRHGEOM 30\n')
        fid.write('Name \"HEC-RAS 2D Mesh %s\"\n' % srhgeomFileName)
    
        fid.write('\n')
    
        fid.write('GridUnit \"%s\" \n' % self.units)        
        
        #all cells
        for cellI in range(self.TwoDAreaCellCounts[0]):
            cell_list = cellFacePointIndexes[cellI,0:cellsFaceOrientationInfo[cellI,1]]

            for i in range(len(cell_list)):
                cell_list[i] += 1

            fid.write("Elem ")
            fid.write("%d " % (cellI+1))  #cellI+1 because SRH-2D is 1-based
            fid.write(" ".join(map(str, cell_list)))
            fid.write("\n")
        
        #all points
        for pointI in range(facePointsCoordinates.shape[0]):
            fid.write("Node %d " % (pointI+1))  #pointI+1 because SRH-2D is 1-based
            curr_point_coordinates = [facePointsCoordinates[pointI,0],
                                      facePointsCoordinates[pointI,1],
                                      facePointsCoordinates[pointI,2]]

            fid.write(" ".join(map(str, curr_point_coordinates)))
            fid.write("\n")

        #NodeString    
        boundary_id = 0 #boundary ID counter
        for k in range(self.totalBoundaries):
            boundary_id += 1
            fid.write("NodeString %d " % boundary_id)

            #loop over all node ID in the current NodeString
            for i in range(self.boundaryTotalPoints[boundary_id-1]):
                fid.write(" %d" % (self.boundaryPointList[boundary_id-1,i]+1)) #all point IDs are +1 becaue SRH-2D is 1-based and RAS2D is 0-based.

                # 10 numbers per line or this is the last node, start a new line
                if (((i + 1) % 10) == 0) or (i == (self.boundaryTotalPoints[boundary_id-1] - 1)):
                    fid.write("\n")

            fid.write("\n")
        
        fid.close()
        

    def exportSRHMATFile(self, srhmatFileName):
        """ Export the SRHMAT file

        Parameters
        ----------
        srhmatFileName

        Returns
        -------

        """
        #only the first 2D area is exported.
        cell_ManningN = self.TwoDAreaCellManningN[0]  #cell Manning's n
        
        print("cell_ManningN", cell_ManningN)
        
        #number of Manning's n zones
        nManningNZones = len(self.ManningNZones)
        
        print("nManningNZones", nManningNZones)
        
        fname = srhmatFileName + '.srhmat'
        print("Writing SRHMAT file: ", fname)
    
        try:
            fid = open(fname, 'w')
        except IOError:
            print('.srhmat error')
            sys.exit()
    
        fid.write('SRHMAT 30\n')
        fid.write('NMaterials %d\n' % (nManningNZones + 1))  #+1 is because SRH-2D also counts the default Manning's n in srhhydro file.
        
        #output MatName
        for matID in range(nManningNZones):
            fid.write('MatName %d \"%s\" \n' % (matID + 1, self.ManningNZones[matID][0].decode("utf-8")))  # +1 because SRH-2D is 1-based
    
        #output cells in different material categories
        for matID in range(nManningNZones):
            if not self.cellsInManningZones[matID]: #this Manning's n zone has no cells
                continue

            fid.write('Material %d ' % (matID+1))
            
            #loop over all cells in current Manning's n zone
            for cellI in range(len(self.cellsInManningZones[matID])):
                fid.write(" %d" % (self.cellsInManningZones[matID][cellI]+1))  #+1 because SRH-2D is 1-based

                # 10 numbers per line or this is the last cell, start a new line
                if (((cellI+1) % 10) == 0) or (cellI == (len(self.cellsInManningZones[matID])-1)):
                    fid.write("\n")

        fid.close()


    def exportBoundariesToVTK(self, boundaryVTKFileName):
        """ Export boundaries of 2D area to VTK (for visual inspection in Paraview and check the ID of NodeString)

        Parameters
        ----------
        boundaryVTKFileName

        Returns
        -------

        """
        #only the boundaries of the first 2D area is exported.
        hec_ras_mesh = self.meshioObjectList[0]
        
        fname = boundaryVTKFileName + '.vtk'
        
        print('Writing RAS2D mesh boundaries to', fname)
        
        try:
            fid = open(fname, 'w')
        except IOError:
            print('boundary vtk file open error')
            sys.exit()
         
        #output header
        fid.write('# vtk DataFile Version 3.0\n')
        fid.write('RAS2D boundaries\n')
        fid.write('ASCII\n')
        fid.write('DATASET POLYDATA\n')
        fid.write('\n')
        
        #output all points in the mesh
        #(a short cut instead of output boundary points only; does not matter because
        #this is for inspection purpose only)
        
        #total number of points in mesh
        totalNumPoints = hec_ras_mesh.points.shape[0]
        
        fid.write('POINTS %d float\n' % totalNumPoints)

        #loop over all points
        for k in range(hec_ras_mesh.points.shape[0]):
            fid.write(" ".join(map(str, hec_ras_mesh.points[k])))
            fid.write("\n")
            
        #calculate total number of boundary points
        totalNumBoundaryPoints = 0
        for k in range(self.totalBoundaries):
            totalNumBoundaryPoints += self.boundaryTotalPoints[k]
            
        #print("totalNumBoundaryPoints = ", totalNumBoundaryPoints)
            
        #output lines (boundaries)
        fid.write('\nLINES %d %d\n' % (self.totalBoundaries, self.totalBoundaries+totalNumBoundaryPoints))
        
        for k in range(self.totalBoundaries):
            fid.write('%d ' % self.boundaryTotalPoints[k])
            fid.write(" ".join(map(str, self.boundaryPointList[k,:self.boundaryTotalPoints[k]])))
            fid.write("\n")
            
        #output line ID (as cell_data)
        fid.write('\nCELL_DATA %d \n' % self.totalBoundaries)
        fid.write('scalars BC_ID integer\n')
        fid.write('LOOKUP_TABLE default\n')
        
        for k in range(self.totalBoundaries):
            fid.write('%d ' % (k+1))   #here k+1 is because SRH-2D is 1-based and RAS2D is 0-based.
        
        fid.write('\n')
            
        fid.close()


    def exportFaceProfilesToVTK(self, faceProfileVTKFileName):
        """ Export face profile of 2D area to VTK (for visual inspection in Paraview)

        Parameters
        ----------
        faceProfileVTKFileName

        Returns
        -------

        """

        #check whether the face profiles have been created; if not,create them (slow calculation)
        if len(self.TwoDAreaFaceProfile) == 0:
            self.TwoDAreaFaceProfile = self.build2DAreaFaceProfile()

        #only the face profiles of the first 2D area is exported.
        faceProfiles = self.TwoDAreaFaceProfile[0]
        
        fname = faceProfileVTKFileName + '.vtk'
        
        print('Writing all face profiles to', fname)     
        
        try:
            fid = open(fname, 'w')
        except IOError:
            print('face profile vtk file open error')
            sys.exit()
         
        #output header
        fid.write('# vtk DataFile Version 3.0\n')
        fid.write('RAS2D face profiles\n')
        fid.write('ASCII\n')
        fid.write('DATASET POLYDATA\n')
        fid.write('\n')
        
        #output all points in the profiles (repetition of points is ok because
        #this is for inspection purpose only)
        
        #total number of points in face profiles = (number of faces X points per profile)
        totalNumPoints = len(faceProfiles)*self.nFaceProfilePoints
        
        fid.write('POINTS %d float\n' % totalNumPoints)
        
        #loop over all points in all face profiles and export their coordinates
        for faceI in range(len(faceProfiles)):
            #loop over all points in current face profile
            for pointI in range(self.nFaceProfilePoints):
                #if pointI ==0: fid.write(" ".join(map(str, faceProfiles[faceI][pointI,:])))
                fid.write(" ".join(map(str, faceProfiles[faceI][pointI,:])))
                fid.write("\n")
        
        #output lines (face profiles)
        fid.write('\nLINES %d %d\n' % (len(faceProfiles), len(faceProfiles)+totalNumPoints))
        
        profileBase = np.arange(0,self.nFaceProfilePoints)
        
        currentLineStartingIndex = 0
        
        for lineI in range(len(faceProfiles)):
            fid.write('%d ' % self.nFaceProfilePoints)
            fid.write(" ".join(map(str, profileBase + currentLineStartingIndex)))
            fid.write("\n")
            
            currentLineStartingIndex += self.nFaceProfilePoints
        
        
        fid.close()
        
        

    def dump_all_data(self):
        """ Dump all data to screen (for debugging purpose)

        Returns
        -------

        """

        print("RAS2D_mesh_data class self-dump:")
        print("    hdf_filename = ", self.hdf_filename)
        print("    terrain_filename = ", self.terrain_filename)
        print("    plan_filename = ", self.plan_filename)
        print("    plan = ", self.plan)
        print("    short_identifier = ", self.short_identifier)
        print("    project_filename = ", self.project_filename)
        
        print("    comp_interval = ", self.comp_interval)
        print("    outp_interval = ", self.outp_interval)
        print("    map_interval = ", self.map_interval)
        
        print("    units = ", self.units)
        print("    short_ID = ", self.short_ID)
        
        print("    start_time = ", self.start_time)
        print("    end_time = ", self.end_time)
        print("    Dpart = ", self.Dpart)
        
        print("    solution_time = ", self.solution_time)
        print("    solution_timedates = ", self.solution_time_date)
        
        print("    2DAreaNames = ", self.TwoDAreaNames)
        print("    2DAreaCellCounts = ", self.TwoDAreaCellCounts)
        
        print("    2DAreaCellPoints = \n", self.TwoDAreaCellPoints)
        print("    2DAreaBoundaryPoints = \n", self.TwoDAreaBoundaryPoints)
        
        print("    TwoDAreaCellDepth = \n", self.TwoDAreaCellDepth)
        print("    TwoDAreaCellWSE = \n", self.TwoDAreaCellWSE)
        print("    TwoDAreapointVx = \n", self.TwoDAreaPointVx)
        print("    TwoDAreapointVy = \n", self.TwoDAreaPointVy)
        print("    TwoDAreapointVz = \n", self.TwoDAreaPointVz)
        
        


def main():
    """ Testing

    Returns
    -------

    """
    my_ras_2d_data = RAS_2D_Data("Muncie2DOnly_SI.p01.hdf","subterrain_exported.tif")
    
    #print(my_ras_2d_data.TwoDAreaFace_FacePoints[0])
    
    #my_ras_2d_data.saveHEC_RAS2D_results_to_VTK(timeStep=2)
    
    #my_ras_2d_data.exportSRHGEOMFile("Muncie2D")
    
    #my_ras_2d_data.exportSRHMATFile("Muncie2D")
    
    #my_ras_2d_data.exportBoundariesToVTK("Muncie2D_boundaries")
    
    my_ras_2d_data.exportFaceProfilesToVTK("Muncie2D_faceprofiles")
    
    #dump all data to screen (debug)
    #my_ras_2d_data.dump_all_data()
    
    print("All done!")
    
if __name__ == "__main__":
    main()
